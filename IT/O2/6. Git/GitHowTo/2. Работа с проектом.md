
Создание проекта (Инициализация репозитория)
```
git init
```

Переименовываем ветку `master` в ветку `main`:
```
git branch -m master main
```

Проверяем текущее состояние репозитория
```
# Используется для отслеживания состояния репозитория и рабочей директории.

git status
```

Добавление файлов в репозиторий
```
git add <имя_файла_или_директории>
```

И коммитим:
```
git commit -m "Initial Commit"
```
Получаем:
``` git
[main (root-commit) 5836970] Initial commit
 1 file changed, 1 insertion(+)
 create mode 100644 hello.html
```

Снова проверяем текущее состояние:
```
git status
```
Получаем:
``` git
On branch main
nothing to commit, working tree clean
```
Команда проверки состояния сообщила, что коммитить нечего. Это означает, что в репозитории уже хранится текущее состояние рабочих файлов, и нет никаких изменений, которые могли бы ожидать записи.

Вносим изменения в файлы и проверьте состояние рабочей директории:
```
git status
```
Получаем:
```git
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   hello.html

no changes added to commit (use "git add" and/or "git commit -a")
```
Первое, что нужно заметить, это то, что Git знает, что файл `hello.html` был изменен, но при этом эти изменения еще не зафиксированы в репозитории.
Сообщение о состоянии дает вам подсказку о том, что нужно делать дальше. Если вы хотите добавить эти изменения в репозиторий, используйте команду `git add`.

Для отмены изменений:
```
git restore
```

##### Изменение файла

Теперь дайте команду Git проиндексировать изменения. Проверьте состояние:
```
git add hello.html
git status
```
Получим:
```git
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   <имя_файла>
```

Изменения файла `hello.html` были проиндексированы. Это означает, что Git теперь знает об изменении, но изменение пока не _перманентно_ (читай, _навсегда_) записано в репозиторий. Следующий коммит будет включать в себя проиндексированные изменения.

Для снятия индесации этих изменений:
```
git restore --staged
```

##### Индексация и коммит

Отдельный шаг индексации в Git позволяет вам разделять большие изменения на маленькие коммиты.

	Предположим, что вы отредактировали три файла (`a.html`, `b.html`, и `c.html`). Теперь вы хотите закоммитить все изменения, при этом чтобы изменения в `a.html` и `b.html` были одним коммитом, в то время как изменения в `c.html` логически не связаны с первыми двумя файлами и должны идти отдельным коммитом.

```
git add a.html
git add b.html
git commit -m "Changes for a and b"
```

```
git add c.html
git commit -m "Unrelated change to c"
```

Разделяя индексацию и коммит, вы имеете возможность с легкостью настроить, что идет в какой коммит.

##### Коммит изменений

###### Закоммитьте изменения

```
git commit -m "<Commit_name>"
```

`commit` – позволит интерактивно редактировать комментарии для коммита.
`-m` – делает комментарий в командной строке.
Без метки `-m` Git перенесет вас в редактор по вашему выбору. Редактор выбирается из следующего списка (в порядке приоритета):
- переменная среды `GIT_EDITOR`
- параметр конфигурации `core.editor`
- переменная среды `VISUAL`
- переменная среды `EDITOR`

###### Проверьте состояние

```
git status
```

Результат:
```git
$ git status
On branch main
nothing to commit, working tree clean
```
Рабочая директория чиста, можем продолжить работу.


##### Изменения, а не файлы

Большинство систем контроля версий работает с файлами: вы добавляете файл в систему, и она отслеживает изменения файла с этого момента.

Git фокусируется на изменениях в файле, а не самом файле. Когда вы осуществляете команду `git add file`, вы не говорите Git добавить файл в репозиторий. Скорее вы говорите, что Git надо отметить текущее состояние файла, коммит которого будет произведен позже.

###### Первое изменение:

Внесем 1-е изменение в наш файл и добавим это изменение в индекс:
```
git add hello.html
```

###### Второе изменение
Добавим 2-е изменение, но пока не будем добавлять это изменеие в индекс. 

Проверим текущий статус:
```
git status
```

Мы увидим, что наш файл указан дважды в состоянии. Первое изменение проиндексировано и готово к коммиту. Второе изменение - непроиндексировано. Если бы мы делали коммит сейчас, заголовки не были бы сохранены в репозиторий.

Проверим:
###### Коммит

Произведем коммит проиндексированного изменения, а затем проверим состояние:
```
git commit -m "Added standard HTML page tags"
git status
```

Статус покажет, что в нашем файле еще есть незаписанные изменения, но область подготовки уже пуста.

##### Добавим второе изменение

добавим второе изменение в индекс, а затем проверим состояние с помощью команды `git status`.

```
git add .
git status
```

Мы увидим, что второе изменение было проиндексировано и готово к коммиту.

`Мы использовали текущую директорию (`.`) в качестве аргумента для добавления. Это самый короткий и удобный способ добавления всех изменений в текущей директории. Но поскольку Git добавляет в индекс _всё_, то _не лишним_ будет проверить состояние репозитория перед запуском `add`, просто чтобы убедиться, что мы не добавили какой-то файл, который не следовало бы добавлять.`


###### Сделаем коммит второго изменения

```
git commit -m "Added HTML header"
```
