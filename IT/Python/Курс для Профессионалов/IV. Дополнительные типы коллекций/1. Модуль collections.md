[Орининальная статья (Real Python, eng, 2021)](https://realpython.com/python-collections-module/)

Модуль [`collections`](https://docs.python.org/3/library/collections.html#module-collections) предоставляет богатый набор **специализированных контейнерных типов данных**, тщательно разработанных для решения конкретных задач программирования по-питоновски эффективно. Модуль также предоставляет wrapper классы, позволяющие безопасно создавать пользовательские классы, которые ведут себя аналогично встроенным типам `dict`, `list` и `str`.

Изучение типов данных и классов в `collections` позволит вам пополнить свой набор инструментов программирования ценным набором надежных и эффективных инструментов.

**В этом руководстве вы узнаете, как:**

- Писать **понятный** и **очевидный** код с помощью `namedtuple`.
- Создавать **эффективные очереди и стеки** с помощью `deque`
- Быстро **подсчитывать объекты** с помощью `Counter`.
- Обрабатывать **недостающие ключи словаря** с помощью `defaultdict`.
- Гарантировать **порядок вставки** ключей с помощью `OrderedDict`.
- Управлять **многочисленными словарями** как единым целым с помощью `ChainMap`.

Чтобы лучше понять типы данных и классы в `collections`, вы должны знать основы работы со встроенными типами данных Python, такими как [lists, tuples](https://realpython.com/python-lists-tuples/) и [dictionaries](https://realpython.com/python-dicts/). Кроме того, последняя часть статьи требует некоторых базовых знаний об [объектно-ориентированном программировании](https://realpython.com/python3-object-oriented-programming/) в Python.

## Модуль `collections`

Еще в [Python 2.4](https://docs.python.org/3/whatsnew/2.4.html#new-improved-and-deprecated-modules), [Raymond Hettinger](https://twitter.com/raymondh) внес новый модуль под названием [`collections`](https://docs.python.org/3/library/collections.html#module-collections) в [стандартную библиотеку](https://docs.python.org/3/library/index.html). Целью было предоставление различных специализированных типов данных коллекций для решения конкретных задач программирования.

В то время `collections` включал только одну структуру данных, **`deque`**, которая была специально разработана как [двусторонняя очередь](https://en.wikipedia.org/wiki/Double-ended_queue), поддерживающая эффективные операции **append** и **pop** на обоих концах последовательности. С этого момента несколько модулей стандартной библиотеки использовали преимущества `deque` для повышения производительности своих классов и структур. Яркими примерами являются [`queue`](https://docs.python.org/3/library/queue.html#module-queue) и [`threading`](https://docs.python.org/3/library/threading.html#module-threading).

Со временем модуль пополнился рядом специализированных контейнерных типов данных:

| Data type                                                                  | Python version | Description |
| -------------------------------------------------------------------------- | -------------- | ----------- |
| [`deque`](https://docs.python.org/3/library/collections.html#collections.deque) | [2.4](https://docs.python.org/3/whatsnew/2.4.html#new-improved-and-deprecated-modules)             | Коллекция, подобная последовательности, которая поддерживает эффективное добавление и удаление элементов с любого конца последовательности          |
| [`defaultdict`](https://docs.python.org/3/library/collections.html#collections.defaultdict) | [2.5](https://docs.python.org/3/whatsnew/2.5.html#new-improved-and-removed-modules) | Подкласс словаря для формирования значений по умолчанию для отсутствующих ключей и автоматического добавления их в словарь                                                                             |
| [`namedtuple()`](https://docs.python.org/3/library/collections.html#collections.namedtuple) | [2.6](https://docs.python.org/3/whatsnew/2.6.html#new-and-improved-modules) | Фабричная функция для создания подклассов кортежа, которая позволяет создавать именованные поля, позволяющие получать доступ к элементам по имени, сохраняя возможность доступа к элементам по индексу |
| [`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict) | [2.7](https://docs.python.org/3/whatsnew/2.7.html#new-and-improved-modules), [3.1](https://docs.python.org/3/whatsnew/3.1.html#pep-372-ordered-dictionaries) | Подкласс словаря, который сохраняет пары ключ-значение упорядоченными в соответствии с тем, когда были вставлены ключи                                                                                 |
| [`Counter`](https://docs.python.org/3/library/collections.html#collections.Counter) | [2.7](https://docs.python.org/3/whatsnew/2.7.html#new-and-improved-modules), [3.1](https://docs.python.org/3/whatsnew/3.1.html#pep-372-ordered-dictionaries) | Подкласс словаря, поддерживающий удобный подсчет уникальных элементов в последовательности или итерабельности                                                                                          |
| [`ChainMap`](https://docs.python.org/3/library/collections.html#collections.ChainMap)       | [3.3](https://docs.python.org/3/whatsnew/3.3.html#collections)                                                                                               | Класс, подобный словарю, который позволяет рассматривать несколько отображений как один объект словаря                                                                                                 |

Помимо этих специализированных типов данных, `collections` также предоставляет три базовых класса, которые облегчают создание пользовательских списков, словарей и [строк](https://realpython.com/python-strings/):

| Class                                                      | Description                                                                    |
| ---------------------------------------------------------- | ------------------------------------------------------------------------------ |
| [`UserDict`](https://realpython.com/inherit-python-dict/)  | Класс-обертка (wrapper) вокруг объекта словаря, облегчающий подклассификацию `dict` |
| [`UserList`](https://realpython.com/inherit-python-list/)  | Класс-обертка (wrapper) вокруг объекта списка, облегчающий подклассификацию `list`.       |
| [`UserString`](https://realpython.com/inherit-python-str/) | Класс-обертка (wrapper) вокруг объекта строки, облегчающий подклассификацию `string`

Необходимость в этих классах-обертках была частично вытеснена возможностью подклассификации соответствующих стандартных встроенных типов данных. Однако иногда использование этих классов является более безопасным и менее подверженным ошибкам, чем использование стандартных типов данных.

После этого краткого введения в `collections` и конкретных сценариев использования, которые могут решить структуры данных и классы в этом модуле, пришло время рассмотреть их более подробно. Перед этим важно отметить, что данный материал является введением в `коллекции` в целом. В большинстве последующих разделов вы увидите синюю подсказку, которая направит вас к статье, посвященной данному классу или функции.

## namedtuple()

`namedtuple()` - это [фабричная функция](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)), которая позволяет создавать подклассы `tuple` с **именованными полями**. Эти поля дают вам прямой доступ к значениям в данном именованном кортеже, используя **точечную нотацию**, как в `obj.attr`.

Необходимость в этой функции возникла потому, что использование индексов для доступа к значениям в обычном кортеже раздражает, затрудняет чтение и приводит к ошибкам. Это особенно верно, если кортеж, с которым вы работаете, имеет несколько элементов и составлен далеко от места, где вы его используете.

>**Примечание:** Ознакомьтесь с [Write Pythonic and Clean Code With namedtuple](https://realpython.com/python-namedtuple/) для более глубокого погружения в то, как использовать `namedtuple` в Python.

Подкласс кортежа с именованными полями, к которым разработчики могут обращаться с помощью точечной нотации, казался желаемой фичей еще в Python 2.6. Это и стало причиной появления функции `namedtuple()`. Подклассы кортежей, которые можно создать с помощью этой функции, обладают большим преимуществом с точки зрения читаемости кода, если сравнивать их с обычными кортежами.

Чтобы представить проблему читаемости кода в перспективе, рассмотрим [`divmod()`](https://docs.python.org/3/library/functions.html#divmod). Эта встроенная функция принимает два (некомплексных) [числа](https://realpython.com/python-numbers/) и возвращает кортеж с **коэффициентом** и **остатком**, которые получаются в результате **целочисленного деления** входных значений:
```python
>>> divmod(12, 5)
(2, 2)
```

Это работает хорошо. Однако, является ли этот результат читабельным? Можете ли вы сказать, что означает каждое число в полученном результате? К счастью, Python предлагает способ улучшить это. Вы можете написать собственную версию `divmod()` с явным результатом, используя `namedtuple`:
```python
from collections import namedtuple

>>> def custom_divmod(x, y):
...     DivMod = namedtuple("DivMod", "quotient remainder")
...     return DivMod(*divmod(x, y))
...

>>> result = custom_divmod(12, 5)
>>> result
DivMod(quotient=2, remainder=2)

>>> result.quotient
2
>>> result.remainder
2
```

Теперь вы знаете обозначение каждого значения в результате. Вы также можете получить доступ к каждому независимому значению, используя точечную нотацию и имя поля.

Чтобы создать новый подкласс кортежа с помощью `namedtuple()`, необходимо два обязательных аргумента:

1.  **`typename`** - это имя класса, который вы создаете. Оно должно быть строкой с [действительным идентификатором Python](https://doc.python.org/3/reference/lexical_analysis.html#identifiers).
2.  **`field_names`** - это список имен полей, которые вы будете использовать для доступа к элементам в результирующем кортеже. Это может быть:
	- [итерируемая](https://docs.python.org/3/glossary.html#term-iterable) последовательность строк, например `["field1", "field2", ..., "fieldN"]`.
	- Строка с именами полей, разделенных пробелами, например `"field1 field2 ... fieldN"`.
	- Строка с именами полей, разделенных запятыми, например, `"field1, field2, ..., fieldN"`.

Например, ниже приведены различные способы создания типичной двумерной `точки` с двумя координатами (`x` и `y`) с помощью `namedtuple()`:
```python
from collections import namedtuple

>>> # Использование списка строк в качестве имен полей
>>> Point = namedtuple("Point", ["x", "y"])
>>> point = Point(2, 4)
>>> point
Point(x=2, y=4)

>>> # Получение доступа к координатам
>>> point.x
2
>>> point.y
4
>>> point[0]
2

>>> # Использование выражения генератора в качестве имен полей
>>> Point = namedtuple("Point", (field for field in "xy"))
>>> Point(2, 4)
Point(x=2, y=4)

>>> # Использование строки с именами полей, разделенных запятыми
>>> Point = namedtuple("Point", "x, y")
>>> Point(2, 4)
Point(x=2, y=4)

>>> # Использование строки с именами полей, разделенных пробелами
>>> Point = namedtuple("Point", "x y")
>>> Point(2, 4)
Point(x=2, y=4)
```

В этих примерах вы сначала создаете `Point`, используя `список` имен полей. Затем вы создаете экземпляр класса `Point`, чтобы создать объект `point`. Обратите внимание, что вы можете получить доступ к `x` и `y` по имени поля, а также по индексу.

В остальных примерах показано, как создать аналогичный именованный кортеж со строкой имен полей, разделенных запятыми, выражением [generator expression](https://realpython.com/introduction-to-python-generators/#building-generators-with-generator-expressions) и строкой имен полей, разделенных пробелами.

Именованные кортежи также предоставляют множество возможностей, которые позволяют определять значения по умолчанию для ваших полей, создавать словарь из данного именованного кортежа, заменять значение заданного поля и многое другое:
```python
from collections import namedtuple

>>> # Объявление значений по умолчанию для полей
>>> Person = namedtuple("Person", "name job", defaults=["Python Developer"])
>>> person = Person("Jane")
>>> person
Person(name='Jane', job='Python Developer')

>>> # Создание словаря из именованного кортежа
>>> person._asdict()
{'name': 'Jane', 'job': 'Python Developer'}

>>> # Замена значения поля
>>> person = person._replace(job="Web Developer")
>>> person
Person(name='Jane', job='Web Developer')
```

Здесь вы сначала создаете класс `Person` с помощью функции `namedtuple()`. На этот раз вы используете необязательный аргумент `defaults`, который принимает последовательность значений по умолчанию для полей кортежа. Обратите внимание, что `namedtuple()` применяет значения по умолчанию к крайним правым полям.

Во втором примере вы создаете словарь из существующего именованного кортежа с помощью метода [`._asdict()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._asdict). Этот метод возвращает новый словарь, который использует имена полей в качестве ключей.

Наконец, вы используете [`._replace()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._replace) для замены исходного значения `job`. Этот метод не обновляет кортеж [in place](https://en.wikipedia.org/wiki/In-place_algorithm), а возвращает новый именованный кортеж с новым значением, хранящимся в соответствующем поле. Есть ли у вас идея, почему `._replace()` возвращает новый именованный кортеж?

## deque

**`deque`** был первой структурой данных в `collections `. Этот тип данных, похожий на последовательность, является развитием [стеков](https://realpython.com/how-to-implement-python-stack/) и [очередей](https://realpython.com/queue-in-python/), разработанным для поддержки эффективных для памяти и быстрых операций **append** и **pop** на обоих концах структуры данных.

>**Примечание:** Слово `deque` произносится как "дек" и означает **d**ouble-**e**nded **que**ue.

В Python операции append и pop в начале `list` являются неэффективными, с [_O_(_n_) сложностью по времени](https://wiki.python.org/moin/TimeComplexity). Эти операции особенно затратны при работе с большими списками, поскольку Python должен переместить все элементы вправо, чтобы вставить новые элементы в начало списка.

С другой стороны, операции append и pop в правой части списка обычно эффективны (_O_(1)), за исключением тех случаев, когда Python приходится перераспределять память, чтобы увеличить базовый список для приема новых элементов.

Для решения этой проблемы в Python был создан `deque`. Операции append и pop с обеих сторон объекта `deque` стабильны и одинаково эффективны, поскольку deques реализованы как [двусвязный список](https://realpython.com/linked-lists-python/#how-to-use-doubly-linked-lists). Именно поэтому deques особенно полезны для создания стеков и очередей.

Возьмем в качестве примера очередь. Она управляет элементами по принципу **Первый вошел/Первый вышел** ([FIFO](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics))). Он работает как труба, где вы вставляете новые элементы с одного конца трубы и выталкиваете старые элементы с другого конца. Добавление элемента в конец очереди называется операцией **enqueue**. Удаление элемента из передней или начальной части очереди называется **dequeue**.

>**Примечание:** Ознакомьтесь с [Python's deque: Implement Efficient Queues and Stacks](https://realpython.com/python-deque/) для подробного изучения использования `deque` в вашем коде Python.

Теперь предположим, что вы моделируете очередь из людей, ожидающих покупки билетов в кино. Вы можете сделать это с помощью `deque`. Каждый раз, когда приходит новый человек, вы записываете его в очередь. Когда человек, стоящий в начале очереди, получает свой билет, вы его удаляете.

Вот как можно смоделировать этот процесс с помощью объекта `deque`:
```python
from collections import deque

>>> ticket_queue = deque()
>>> ticket_queue
deque([])

>>> # Люди встают в очередь
>>> ticket_queue.append("Jane")
>>> ticket_queue.append("John")
>>> ticket_queue.append("Linda")

>>> ticket_queue
deque(['Jane', 'John', 'Linda'])

>>> # Люди купили свои билеты
>>> ticket_queue.popleft()
'Jane'
>>> ticket_queue.popleft()
'John'
>>> ticket_queue.popleft()
'Linda'

>>> # В очереди нет людей
>>> ticket_queue.popleft()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: pop from an empty deque
```

Здесь вы сначала создаете пустой объект `deque` для представления очереди людей. Чтобы добавить человека в очередь, вы можете использовать [`.append()`](https://docs.python.org/3/library/collections.html#collections.deque.append), который добавляет элементы в правый конец deque. Для удаления человека из очереди используется [`.popleft()`](https://docs.python.org/3/library/collections.html#collections.deque.popleft), который удаляет и возвращает элементы в левом конце очереди.

>**Примечание:** В стандартной библиотеке Python вы найдете [`queue`](https://docs.python.org/3/library/queue.html#module-queue). Этот модуль реализует очереди с несколькими порождающими и несколькими потребляющими элементами, полезные для безопасного обмена информацией между несколькими потоками.

Инициализатор `deque` принимает два необязательных аргумента:

1.  **`iterable`** содержит итерируемый объект, который служит в качестве инициализатора.
2.  **`maxlen`** содержит [целое число](https://realpython.com/python-numbers/#integers), определяющее максимальную длину `deque`.

Если вы не передадите `iterable`, то получите пустой deque. Если вы передадите значение [`maxlen`](https://docs.python.org/3/library/collections.html#collections.deque.maxlen), то ваш deque будет хранить только до `maxlen` элементов.

Наличие `maxlen` - удобная функция. Например, вам нужно реализовать список последних файлов в одном из ваших приложений. В этом случае вы можете поступить следующим образом:
```python
from collections import deque

>>> recent_files = deque(["core.py", "README.md", "__init__.py"], maxlen=3)

>>> recent_files.appendleft("database.py")
>>> recent_files
deque(['database.py', 'core.py', 'README.md'], maxlen=3)

>>> recent_files.appendleft("requirements.txt")
>>> recent_files
deque(['requirements.txt', 'database.py', 'core.py'], maxlen=3)
```

Когда deque достигает максимального размера (в данном случае три файла), добавление нового файла на одном из концов deque автоматически выбрасывает файл на противоположном конце. Если вы не зададите значение `maxlen`, то deque может вырасти до произвольного количества элементов.

Итак, вы изучили основы работы с deque, включая создание deque и добавление и удаление элементов с обоих концов данного deque. Deques предоставляют некоторые дополнительные возможности интерфейса, похожего на список. Вот некоторые из них:
```python
from collections import deque

>>> # Использование различных итерируемых объектов для создания deques
>>> deque((1, 2, 3, 4))
deque([1, 2, 3, 4])

>>> deque([1, 2, 3, 4])
deque([1, 2, 3, 4])

>>> deque("abcd")
deque(['a', 'b', 'c', 'd'])

>>> # В отличие от списков, deque не поддерживает функцию .pop() с произвольными индексами
>>> deque("abcd").pop(2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: pop() takes no arguments (1 given)

>>> # Расширение существующего deque
>>> numbers = deque([1, 2])
>>> numbers.extend([3, 4, 5])
>>> numbers
deque([1, 2, 3, 4, 5])

>>> numbers.extendleft([-1, -2, -3, -4, -5])
>>> numbers
deque([-5, -4, -3, -2, -1, 1, 2, 3, 4, 5])

>>> # Вставка элемента в заданную позицию
>>> numbers.insert(5, 0)
>>> numbers
deque([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])
```

В этих примерах вы сначала создаете deques, используя различные типы итерируемых объектов для их инициализации. Разница между `deque` и `list` заключается в том, что `deque.pop()` не поддерживает извлечение элемента по заданному индексу.

Обратите внимание, что `deque` предоставляет родственные методы для `.append()`, [`.pop()`](https://docs.python.org/3/library/collections.html#collections.deque.pop) и [`.extend()`](https://docs.python.org/3/library/collections.html#collections.deque.extend) с суффиксом `left`, чтобы указать, что они выполняют соответствующую операцию на левом конце базовой deque.

Deques также поддерживают операции последовательности:

| Method                                                                                          | Description                                     |
| ----------------------------------------------------------------------------------------------- | ----------------------------------------------- |
| [`.clear()`](https://docs.python.org/3/library/collections.html#collections.deque.clear)        | Удаление всех элементов из deque            |
| [`.copy()`](https://docs.python.org/3/library/collections.html#collections.deque.copy)          | Создание поверхностной копии deque                |
| [`.count(x)`](https://docs.python.org/3/library/collections.html#collections.deque.count)       | Подсчет количества элементов deque, равных `x`. |
| [`.remove(value)`](https://docs.python.org/3/library/collections.html#collections.deque.remove) | Удаление первого вхождения `value`.          | 

Еще одной интересной особенностью deques является возможность поворота их элементов с помощью `.rotate()`:
```python
from collections import deque

>>> ordinals = deque(["first", "second", "third"])
>>> ordinals.rotate()
>>> ordinals
deque(['third', 'first', 'second'])

>>> ordinals.rotate(2)
>>> ordinals
deque(['first', 'second', 'third'])

>>> ordinals.rotate(-2)
>>> ordinals
deque(['third', 'first', 'second'])

>>> ordinals.rotate(-1)
>>> ordinals
deque(['first', 'second', 'third'])
```

Этот метод вращает deque на `n` шагов вправо. По умолчанию значение `n` равно `1`. Если вы зададите отрицательное значение `n`, то поворот произойдет влево.

Наконец, вы можете использовать индексы для доступа к элементам deque, но вы не можете использовать [срезы](https://docs.python.org/3/glossary.html#term-slice) deque:
```python
from collections import deque

>>> ordinals = deque(["first", "second", "third"])
>>> ordinals[1]
'second'

>>> ordinals[0:2]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: sequence index must be integer, not 'slice'
```

Deques поддерживают индексирование, но, что интересно, они не поддерживают срезы. Когда вы пытаетесь получить срез из существующего deque, вы получаете `TypeError`. Это происходит потому, что выполнение операций со срезами в связанном списке было бы неэффективным, поэтому такая операция недоступна.


##  defaultdict

Частая проблема, с которой вы столкнетесь при работе со [словарями](https://realpython.com/python-dicts/) в Python, состоит в том, как обрабатывать отсутствующие ключи. Если вы попытаетесь получить доступ к ключу, который не существует в данном словаре, то вы получите `KeyError`:
```python
favorites = {"pet": "dog", "color": "blue", "language": "Python"}

>>> favorites["fruit"]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'fruit'
```

Существует несколько подходов к решению этой проблемы. Например, вы можете использовать [`.setdefault()`](https://docs.python.org/3/library/stdtypes.html#dict.setdefault). Этот метод принимает ключ в качестве аргумента. Если ключ существует в словаре, то он возвращает соответствующее значение. В противном случае метод вставляет ключ, присваивает ему значение по умолчанию и возвращает это значение:
```python
favorites = {"pet": "dog", "color": "blue", "language": "Python"}

>>> favorites.setdefault("fruit", "apple")
'apple'

>>> favorites
{'pet': 'dog', 'color': 'blue', 'language': 'Python', 'fruit': 'apple'}

>>> favorites.setdefault("pet", "cat")
'dog'

>>> favorites
{'pet': 'dog', 'color': 'blue', 'language': 'Python', 'fruit': 'apple'}
```

В этом примере вы используете `.setdefault()` для создания значения по умолчанию для `fruit`. Поскольку этот ключ не существует в `favorites`, `.setdefault()` создает его и присваивает ему значение `apple`. Если вы вызовете `.setdefault()` с существующим ключом, то вызов не повлияет на словарь, и ваш ключ будет содержать исходное значение вместо значения по умолчанию.

Вы также можете использовать `.get()` для возврата подходящего значения по умолчанию, если данный ключ отсутствует:
```python
favorites = {"pet": "dog", "color": "blue", "language": "Python"}

>>> favorites.get("fruit", "apple")
'apple'

>>> favorites
{'pet': 'dog', 'color': 'blue', 'language': 'Python'}
```

Здесь `.get()` возвращает `apple`, потому что ключ отсутствует в исходном словаре. Однако `.get()` не создает новый ключ для вас.

Поскольку работа с отсутствующими ключами в словарях - это обычная необходимость, Python `collections` также предоставляет инструмент для этого. Тип `defaultdict` является подклассом `dict`, призванным помочь вам с отсутствующими ключами.

>**Примечание:** Ознакомьтесь с [Using the Python defaultdict Type for Handling Missing Keys](https://realpython.com/python-defaultdict/) для более глубокого погружения в использование `defaultdict` в Python.

Конструктор `defaultdict` принимает в качестве первого аргумента объект функции. Когда вы обращаетесь к несуществующему ключу, `defaultdict` автоматически вызывает эту функцию без аргументов, чтобы создать подходящее значение по умолчанию для данного ключа.

Для обеспечения своей функциональности `defaultdict` хранит входную функцию в [`.default_factory`](https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory), а затем переопределяет [`.__missing__()`](https://docs.python.org/3/library/collections.html#collections.defaultdict.__missing__) для автоматического вызова функции и создания значения по умолчанию при обращении к отсутствующим ключам.

Вы можете использовать любую вызываемую функцию для инициализации объектов `defaultdict`. Например, с помощью [`int()`](https://docs.python.org/3/library/functions.html#int) вы можете создать подходящий **счетчик** для подсчета различных объектов:
```python
from collections import defaultdict

>>> counter = defaultdict(int)
>>> counter
defaultdict(<class 'int'>, {})
>>> counter["dogs"]
0
>>> counter
defaultdict(<class 'int'>, {'dogs': 0})

>>> counter["dogs"] += 1
>>> counter["dogs"] += 1
>>> counter["dogs"] += 1
>>> counter["cats"] += 1
>>> counter["cats"] += 1
>>> counter
defaultdict(<class 'int'>, {'dogs': 3, 'cats': 2})
```

IВ этом примере вы создаете пустой `defaultdict` с `int()` в качестве первого аргумента. Когда вы обращаетесь к несуществующему ключу, словарь автоматически вызывает `int()`, который возвращает `0` в качестве значения по умолчанию для данного ключа. Такой объект `defaultdict` весьма полезен, когда речь идет о подсчете в Python.

Еще один распространенный случай использования `defaultdict` - это группировка. В этом случае удобной фабричной функцией является `list()`:
```python
from collections import defaultdict

>>> pets = [
...     ("dog", "Affenpinscher"),
...     ("dog", "Terrier"),
...     ("dog", "Boxer"),
...     ("cat", "Abyssinian"),
...     ("cat", "Birman"),
... ]

>>> group_pets = defaultdict(list)

>>> for pet, breed in pets:
...     group_pets[pet].append(breed)
...

>>> for pet, breeds in group_pets.items():
...     print(pet, "->", breeds)
...
dog -> ['Affenpinscher', 'Terrier', 'Boxer']
cat -> ['Abyssinian', 'Birman']
```

В этом примере у вас есть необработанные данные о домашних животных и их породах, и вам нужно сгруппировать их по видам домашних животных. Чтобы сделать это, вы используете `list()` в качестве `.default_factory` при создании экземпляра `defaultdict`. Это позволит вашему словарю автоматически создать пустой список (`[]`) в качестве значения по умолчанию для каждого отсутствующего ключа, к которому вы обращаетесь. Затем вы используете этот список для хранения пород ваших питомцев.

Наконец, следует отметить, что поскольку `defaultdict` является подклассом `dict`, он предоставляет тот же интерфейс. Это означает, что вы можете использовать объекты `defaultdict` так же, как вы бы использовали обычный словарь.


## OrderedDict

Иногда вам нужно, чтобы ваши словари помнили порядок, в котором вставляются пары ключ-значение. Обычные [словари](https://realpython.com/iterate-through-dictionary-python/#a-few-words-on-dictionaries) в Python были _неупорядоченными_ [структурами данных](https://realpython.com/python-data-structures/) в течение многих лет. Поэтому в 2008 году в [PEP 372](https://www.python.org/dev/peps/pep-0372/) появилась идея добавить новый класс словарей в `collections `.

Новый класс будет запоминать порядок элементов на основе момента, в который были вставлены ключи. Так возникла идея [`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict).

`OrderedDict` был представлен в [Python 3.1](https://docs.python.org/3/whatsnew/3.1.html). Его интерфейс прикладного программирования (API) практически такой же, как и у `dict`. Однако `OrderedDict` выполняет итерации по ключам и значениям в том же порядке, в котором ключи были впервые вставлены в словарь. Если вы присваиваете новое значение существующему ключу, то порядок пары ключ-значение остается неизменным. Если запись удалена и вставлена заново, то она будет перемещена в конец словаря.

>**Примечание:** Ознакомьтесь с [OrderedDict vs dict in Python: The Right Tool for the Job](https://realpython.com/python-ordereddict/) для более глубокого погружения в `OrderedDict` и почему вы должны рассмотреть возможность его использования.

Существует несколько способов создания объектов `OrderedDict`. Большинство из них идентичны тому, как вы создаете обычный словарь. Например, вы можете создать пустой упорядоченный словарь, создав экземпляр объекта класса без аргументов, а затем вставить пары ключ-значение по мере необходимости:
```python
from collections import OrderedDict

>>> life_stages = OrderedDict()

>>> life_stages["childhood"] = "0-9"
>>> life_stages["adolescence"] = "9-18"
>>> life_stages["adulthood"] = "18-65"
>>> life_stages["old"] = "+65"

>>> for stage, years in life_stages.items():
...     print(stage, "->", years)
...
childhood -> 0-9
adolescence -> 9-18
adulthood -> 18-65
old -> +65
```

В этом примере вы создаете пустой упорядоченный словарь, инстанцируя (создавая экземпляр объекта класса) `OrderedDict` без аргументов. Затем вы добавляете пары ключ-значение в словарь, как и в обычный словарь.

При [итерации по словарю](https://realpython.com/iterate-through-dictionary-python/), `life_stages`, вы получаете пары ключ-значение в том же порядке, в котором вы вставляли их в словарь. Гарантия порядка элементов - это основная проблема, которую решает `OrderedDict`.

В Python 3.6 появилась [новая реализация `dict`](https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation). Эта реализация предоставляет неожиданную новую возможность: теперь обычные словари сохраняют свои элементы в том же порядке, в котором они были впервые вставлены.

Изначально эта возможность считалась деталью реализации, и документация рекомендовала не полагаться на нее. Однако, начиная с [Python 3.7](https://realpython.com/python37-new-features/), [функция](https://mail.python.org/pipermail/python-dev/2017-December/151283.html) официально является частью спецификации языка. Итак, в чем смысл использования `OrderedDict`?

Есть некоторые особенности `OrderedDict`, которые все еще делают его ценным:

1.  **Сообщение о намерении:** С `OrderedDict` ваш код ясно дает понять, что порядок элементов в словаре важен. Вы четко сообщаете, что ваш код нуждается или полагается на порядок элементов в исходном словаре.
2.  **Контроль над порядком элементов:** С `OrderedDict` у вас есть доступ к [`.move_to_end()`](https://docs.python.org/3/library/collections.html#collections.OrderedDict.move_to_end), который является методом, позволяющим вам манипулировать порядком элементов в вашем словаре. Вы также получите расширенную вариацию [`.popitem()`](https://docs.python.org/3/library/collections.html#collections.OrderedDict.popitem), которая позволяет удалять элементы с любого конца исходного словаря.
3.  **Поведение проверки равенства:** С `OrderedDict`, проверки равенства между словарями учитывают порядок элементов. Таким образом, если у вас есть два упорядоченных словаря с одинаковой группой элементов, но в разном порядке, то ваши словари будут считаться неравными.

Есть еще одна причина для использования `OrderedDict`: **обратная совместимость**. Полагаясь на обычные объекты `dict` для сохранения порядка элементов, вы сломаете свой код в средах, использующих версии Python старше 3.6.

Итак, пришло время увидеть некоторые из этих замечательных возможностей `OrderedDict` в действии:
```python
from collections import OrderedDict

>>> letters = OrderedDict(b=2, d=4, a=1, c=3)
>>> letters
OrderedDict([('b', 2), ('d', 4), ('a', 1), ('c', 3)])

>>> # Перемещение b в правый конец
>>> letters.move_to_end("b")
>>> letters
OrderedDict([('d', 4), ('a', 1), ('c', 3), ('b', 2)])

>>> # Перемещение b в левый конец
>>> letters.move_to_end("b", last=False)
>>> letters
OrderedDict([('b', 2), ('d', 4), ('a', 1), ('c', 3)])

>>> # Сортировка букв по ключу
>>> for key in sorted(letters):
...     letters.move_to_end(key)
...

>>> letters
OrderedDict([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
```

В этих примерах вы используете [`.move_to_end()`](https://docs.python.org/3/library/collections.html#collections.OrderedDict.move_to_end), чтобы переместить элементы и изменить порядок `letters`. Обратите внимание, что `.move_to_end()` принимает необязательный аргумент `last`, который позволяет вам контролировать, в какой конец словаря вы хотите переместить элементы. Этот метод очень удобен, когда вам нужно отсортировать элементы в словарях или каким-либо образом изменить их порядок.

Еще одно важное различие между `OrderedDict` и обычным словарем заключается в том, как они сравниваются на равенство:
```python
from collections import OrderedDict

>>> # Обычные словари сравнивают только содержимое
>>> letters_0 = dict(a=1, b=2, c=3, d=4)
>>> letters_1 = dict(b=2, a=1, d=4, c=3)
>>> letters_0 == letters_1
True

>>> # Упорядоченные словари сравнивают содержимое и порядок расположения
>>> letters_0 = OrderedDict(a=1, b=2, c=3, d=4)
>>> letters_1 = OrderedDict(b=2, a=1, d=4, c=3)
>>> letters_0 == letters_1
False

>>> letters_2 = OrderedDict(a=1, b=2, c=3, d=4)
>>> letters_0 == letters_2
True
```

Здесь `letters_1` имеет другой порядок элементов, чем `letters_0`. При использовании обычных словарей это различие не имеет значения, и оба словаря сравниваются одинаково. С другой стороны, когда вы используете упорядоченные словари, `letters_0` и `letters_1` не равны. Это происходит потому, что при проверке равенства между упорядоченными словарями учитывается не только их содержимое, но и порядок следования элементов.


## Counter

Подсчет объектов - распространенная операция в программировании. Допустим, вам нужно подсчитать, сколько раз данный элемент встречается в списке или итерируемом объекте. Если ваш список короткий, то подсчет его элементов может быть простым и быстрым. Если у вас длинный список, то подсчет элементов будет более сложной задачей.

Для подсчета объектов обычно используется **счетчик**, или целочисленная [переменная](https://realpython.com/python-variables/) с начальным значением ноль. Затем счетчик увеличивается, чтобы отразить количество повторений данного объекта.

В Python для одновременного подсчета нескольких различных объектов можно использовать словарь. В этом случае ключи будут хранить отдельные объекты, а значения - количество повторений данного объекта, или **счетчик** объекта.

Вот пример подсчета букв в слове `’mississippi’` с помощью обычного словаря и цикла [`for`] (https://realpython.com/python-for-loop/):
```python
word = "mississippi"
>>> counter = {}

>>> for letter in word:
...     if letter not in counter:
...         counter[letter] = 0
...     counter[letter] += 1
...

>>> counter
{'m': 1, 'i': 4, 's': 4, 'p': 2}
```

Цикл перебирает буквы в `word`. [условный оператор](https://realpython.com/python-conditional-statements/) проверяет, нет ли букв в словаре, и инициализирует счетчик букв нулем. Последний шаг заключается в увеличении счетчика букв по мере выполнения цикла.

Как вы уже знаете, объекты `defaultdict` удобны при подсчете, поскольку вам не нужно проверять, существует ли ключ. Словарь гарантирует соответствующие значения по умолчанию для любых отсутствующих ключей:
```python
from collections import defaultdict

>>> counter = defaultdict(int)

>>> for letter in "mississippi":
...     counter[letter] += 1
...

>>> counter
defaultdict(<class 'int'>, {'m': 1, 'i': 4, 's': 4, 'p': 2})
```

В этом примере вы создаете объект `defaultdict` и инициализируете его с помощью `int()`. Используя `int()` в качестве фабричной функции, базовый словарь по умолчанию автоматически создает недостающие ключи и удобно инициализирует их c нулевым значением. Затем вы увеличиваете значение текущего ключа, чтобы вычислить конечное количество букв в `'mississippi'`.

Как и в случае с другими распространенными проблемами программирования, в Python также есть эффективный инструмент для решения проблемы подсчета. В `collections` вы найдете [`Counter`](https://docs.python.org/3/library/collections.html#collections.Counter), который является подклассом `dict`, специально разработанным для подсчета объектов.

Вот как вы можете написать пример `'mississippi'`, используя `Counter`:
```python
from collections import Counter

>>> Counter("mississippi")
Counter({'i': 4, 's': 4, 'p': 2, 'm': 1})
```

Ух ты! Это было быстро! Одна строчка кода - и готово. В этом примере `Counter` выполняет итерацию над `"mississippi"`, создавая словарь с буквами в качестве ключей и их частотой в качестве значений.

>**Примечание:** Ознакомьтесь с [Python's Counter: The Pythonic Way to Counts](https://realpython.com/python-counter/) для более глубокого погружения в `Counter` и как использовать его для эффективного подсчета объектов.

Существует несколько различных способов создания `Counter`. Вы можете использовать [списки, кортежи](https://realpython.com/python-lists-tuples/), или любые итерируемые объекты с повторяющимися элементами. Единственным ограничением является то, что ваши объекты должны быть [хэшируемыми](https://docs.python.org/3/glossary.html#term-hashable):
```python
from collections import Counter

>>> Counter([1, 1, 2, 3, 3, 3, 4])
Counter({3: 3, 1: 2, 2: 1, 4: 1})

>>> Counter(([1], [1]))
Traceback (most recent call last):
  ...
TypeError: unhashable type: 'list'
```

Целые числа можно хэшировать, поэтому `Counter` работает правильно. С другой стороны, списки не являются хэшируемыми, поэтому `Counter` завершается с ошибкой `TypeError`.

Быть **хешируемым** означает, что ваши объекты должны иметь **хеш-значение**, которое никогда не меняется в течение их жизни. Это требование, потому что эти объекты будут работать как ключи словаря. В Python [неизменяемые](https://docs.python.org/3/glossary.html#term-immutable) объекты также являются хэшируемыми.

>**Примечание:** В `Counter`, очень оптимизированная [C-функция](https://github.com/python/cpython/blob/73b20ae2fb7a5c1374aa5c3719f64c53d29fa0d2/Modules/_collectionsmodule.c#L2307) обеспечивает функциональность подсчета. Если эта функция по какой-то причине недоступна, то класс использует эквивалентную, но менее эффективную функцию [Python](https://github.com/python/cpython/blob/6f1e8ccffa5b1272a36a35405d3c4e4bbba0c082/Lib/collections/__init__.py#L503).

Поскольку `Counter` является подклассом `dict`, их интерфейсы в основном одинаковы. Однако есть несколько нюансов. Первое отличие заключается в том, что `Counter` не реализует [`.fromkeys()`](https://docs.python.org/3/library/collections.html#collections.Counter.fromkeys). Это позволяет избежать несоответствий, таких как `Counter.fromkeys("abbbc", 2)`, в котором каждая буква будет иметь начальный счетчик `2`, независимо от того, какое реальное количество букв она имеет во входной итерируемой строке.

Второе отличие заключается в том, что [`.update()`](https://docs.python.org/3/library/collections.html#collections.Counter.update) не заменяет счетчик (значение) существующего объекта (ключа) новым счетчиком. Он складывает оба счетчика вместе:
```python
from collections import Counter

>>> letters = Counter("mississippi")
>>> letters
Counter({'i': 4, 's': 4, 'p': 2, 'm': 1})

>>> # Обновление подсчетов m и i
>>> letters.update(m=3, i=4)
>>> letters
Counter({'i': 8, 'm': 4, 's': 4, 'p': 2})

>>> # Добавление новой пары ключ-счетчик
>>> letters.update({"a": 2})
>>> letters
Counter({'i': 8, 'm': 4, 's': 4, 'p': 2, 'a': 2})

>>> # Обновление с другим счетчиком
>>> letters.update(Counter(["s", "s", "p"]))
>>> letters
Counter({'i': 8, 's': 6, 'm': 4, 'p': 3, 'a': 2})
```

Здесь вы обновляете количество для `m` и `i`. Теперь эти буквы содержат _сумму_ их первоначального количества плюс значение, которое вы передали им через `.update()`. Если вы используете ключ, которого нет в исходном счетчике, то `.update()` создает новый ключ с соответствующим значением. Наконец, `.update()` принимает итерируемые значения, маппинги, ключевые аргументы, а также другие счетчики.

>**Примечание:** Поскольку `Counter` является подклассом `dict`, нет никаких ограничений на объекты, которые вы можете хранить в ключах и значениях ваших счетчиков. Ключи могут хранить любые хэшируемые объекты, в то время как значения могут хранить любые объекты. Однако, чтобы логически работать как счетчики, значения должны быть целыми числами, представляющими количество.

Еще одно отличие между `Counter` и `dict` заключается в том, что обращение к отсутствующему ключу возвращает `0`, а не вызывает ошибку `KeyError`:
```python
from collections import Counter

>>> letters = Counter("mississippi")
>>> letters["a"]
0
```

Такое поведение сигнализирует о том, что счетчик несуществующего в нем объекта равен нулю. В данном примере буква `"a"` отсутствует в исходном слове, поэтому ее счетчик равен `0`.

В Python `Counter` также полезен для эмуляции [multiset](https://en.wikipedia.org/wiki/Multiset) или **bag**. Multiset похожи на [множества](https://en.wikipedia.org/wiki/Set_(mathematics)), но они допускают несколько экземпляров заданного элемента. Количество экземпляров элемента называется его **множественностью**. Например, вы можете иметь multiset {1, 1, 2, 2, 3, 3, 3, 4, 4}.

Когда вы используете `Counter` для эмуляции multiset, ключи представляют элементы, а значения - их соответствующую множественность:
```python
from collections import Counter

>>> multiset = Counter({1, 1, 2, 3, 3, 3, 4, 4})
>>> multiset
Counter({1: 1, 2: 1, 3: 1, 4: 1})

>>> multiset.keys() == {1, 2, 3, 4}
True
```

Здесь ключи `multiset` эквивалентны множеству Python. Значения содержат множественность каждого элемента множества.

Python` `Counter` предоставляет несколько дополнительных возможностей, которые помогают работать с ними как с мультимножествами. Например, вы можете инициализировать ваши счетчики с помощью отображения элементов и их множественности. Вы также можете выполнять математические операции над множественностью элементов и многое другое.

Допустим, вы работаете в местном приюте для животных. У вас есть определенное количество питомцев, и вам нужно вести учет того, сколько питомцев усыновляется каждый день и сколько питомцев поступает в приют и покидает его. В этом случае вы можете использовать `Counter`:
```python
from collections import Counter

>>> inventory = Counter(dogs=23, cats=14, pythons=7)

>>> adopted = Counter(dogs=2, cats=5, pythons=1)
>>> inventory.subtract(adopted)
>>> inventory
Counter({'dogs': 21, 'cats': 9, 'pythons': 6})

>>> new_pets = {"dogs": 4, "cats": 1}
>>> inventory.update(new_pets)
>>> inventory
Counter({'dogs': 25, 'cats': 10, 'pythons': 6})

>>> inventory = inventory - Counter(dogs=2, cats=3, pythons=1)
>>> inventory
Counter({'dogs': 23, 'cats': 7, 'pythons': 5})

>>> new_pets = {"dogs": 4, "pythons": 2}
>>> inventory += new_pets
>>> inventory
Counter({'dogs': 27, 'cats': 7, 'pythons': 7})
```

Это здорово! Теперь вы можете вести учет своих питомцев с помощью `Counter`. Обратите внимание, что вы можете использовать `.subtract()` и `.update()` для вычитания и добавления количества или умножения. Вы также можете использовать операторы сложения (`+`) и вычитания (`-`).

С объектами `Counter` в качестве мультимножеств в Python можно делать еще много чего, так что попробуйте!


## ChainMap

Python `ChainMap` объединяет несколько словарей и других [mapping-объектов](https://docs.python.org/3/glossary.html#term-mapping) вместе для создания единого объекта, который работает почти как обычный словарь. Другими словами, он берет несколько mapping-объектов и делает их логически единым целым.

Объекты `ChainMap` являются **обновляемыми представлениями**, что означает, что изменения в любом из цепочек mapping-объектов влияют на объект `ChainMap` в целом. Это происходит потому, что `ChainMap` не объединяет входные mapping-объекты вместе. Она хранит список mapping-объектов и реализует обычные словарные операции поверх этого списка. Например, поиск ключа последовательно просматривает список mapping-объектов, пока не найдет ключ.

>**Примечание:** Ознакомьтесь с [Python's ChainMap: эффективное управление несколькими контекстами](https://realpython.com/python-chainmap/) для более глубокого погружения в использование `ChainMap` в вашем коде Python.

Когда вы работаете с объектами `ChainMap`, у вас может быть несколько словарей с уникальными или повторяющимися ключами.

В любом случае, `ChainMap` позволяет вам рассматривать все ваши словари как один. Если у вас уникальные ключи для всех ваших словарей, вы можете обращаться к ним и обновлять их, как если бы вы работали с одним словарем.

Если у вас есть повторяющиеся ключи в словарях, помимо управления словарями как единым целым, вы также можете воспользоваться внутренним списком mapping-обектов для определения своего рода **приоритета доступа**. Благодаря этой возможности, объекты `ChainMap` отлично подходят для работы с несколькими контекстами.

К примеру, допустим, вы работаете с приложением [интерфейс командной строки (CLI)](https://en.wikipedia.org/wiki/Command-line_interface). Приложение позволяет пользователю использовать прокси-сервис для подключения к Интернету. Приоритеты настроек следующие:

1.  Опции командной строки (`--proxy`, `-p`)
2.  Локальные файлы конфигурации в домашней директории пользователя
3.  Глобальная конфигурация прокси

Если пользователь указывает прокси в командной строке, то приложение должно использовать этот прокси. В противном случае приложение должно использовать прокси, предоставленный в следующем объекте конфигурации, и так далее. Это один из наиболее распространенных случаев использования `ChainMap`. В этой ситуации вы можете поступить следующим образом:
```python
from collections import ChainMap

>>> cmd_proxy = {}  # The user doesn't provide a proxy
>>> local_proxy = {"proxy": "proxy.local.com"}
>>> global_proxy = {"proxy": "proxy.global.com"}

>>> config = ChainMap(cmd_proxy, local_proxy, global_proxy)
>>> config["proxy"]
'proxy.local.com'
```

`ChainMap` позволяет определить соответствующий приоритет для конфигурации прокси приложения. При поиске ключа просматривается `cmd_proxy`, затем `local_proxy`, и наконец `global_proxy`, возвращая первый экземпляр имеющегося ключа. В этом примере пользователь не указал прокси в командной строке, поэтому ваше приложение использует прокси в `local_proxy`.

В целом, объекты `ChainMap` ведут себя аналогично обычным объектам `dict`. Однако у них есть некоторые дополнительные возможности. Например, у них есть публичный атрибут [`.maps`](https://docs.python.org/3/library/collections.html#collections.ChainMap.maps), который содержит внутренний список mapping-объектов:
```python
from collections import ChainMap

>>> numbers = {"one": 1, "two": 2}
>>> letters = {"a": "A", "b": "B"}

>>> alpha_nums = ChainMap(numbers, letters)
>>> alpha_nums.maps
[{'one': 1, 'two': 2}, {'a': 'A', 'b': 'B'}]
```

Атрибут экземпляра  класса `.maps` дает вам доступ к внутреннему списку mapping-объектов. Этот список можно обновлять. Вы можете добавлять и удалять mapping-объекты вручную, выполнять итерации по списку и многое другое.

Кроме того, `ChainMap` предоставляет метод [`.new_child()`](https://docs.python.org/3/library/collections.html#collections.ChainMap.new_child) и свойство [`.parents`](https://docs.python.org/3/library/collections.html#collections.ChainMap.parents):
```python
from collections import ChainMap

>>> dad = {"name": "John", "age": 35}
>>> mom = {"name": "Jane", "age": 31}
>>> family = ChainMap(mom, dad)
>>> family
ChainMap({'name': 'Jane', 'age': 31}, {'name': 'John', 'age': 35})

>>> son = {"name": "Mike", "age": 0}
>>> family = family.new_child(son)

>>> for person in family.maps:
...     print(person)
...
{'name': 'Mike', 'age': 0}
{'name': 'Jane', 'age': 31}
{'name': 'John', 'age': 35}

>>> family.parents
ChainMap({'name': 'Jane', 'age': 31}, {'name': 'John', 'age': 35})
```

С помощью `.new_child()` вы создаете новый объект `ChainMap`, содержащий новый map (`son`), за которым следуют все map текущего экземпляра. Map, переданный в качестве первого аргумента, становится первым в списке maps. Если вы не передали map, то метод использует пустой словарь.

Свойство `parents` возвращает новый объект `ChainMap`, содержащий все maps в текущем экземпляре, кроме первого. Это полезно, когда вам нужно пропустить первый map при поиске ключа.

Последняя особенность `ChainMap` заключается в том, что операции изменения, такие как обновление ключей, добавление новых ключей, удаление существующих ключей, извлечение ключей и очистка словаря, действуют на первый объект во внутреннем списке mapping-объект:
```python
from collections import ChainMap

>>> numbers = {"one": 1, "two": 2}
>>> letters = {"a": "A", "b": "B"}

>>> alpha_nums = ChainMap(numbers, letters)
>>> alpha_nums
ChainMap({'one': 1, 'two': 2}, {'a': 'A', 'b': 'B'})

>>> # Добавление новой пары ключ-значение
>>> alpha_nums["c"] = "C"
>>> alpha_nums
ChainMap({'one': 1, 'two': 2, 'c': 'C'}, {'a': 'A', 'b': 'B'})

>>> # Извлечение ключа, который существует в первом словаре
>>> alpha_nums.pop("two")
2
>>> alpha_nums
ChainMap({'one': 1, 'c': 'C'}, {'a': 'A', 'b': 'B'})

>>> # Удаление ключей, которые не существуют в первом словаре, но существуют в других.
>>> del alpha_nums["a"]
Traceback (most recent call last):
  ...
KeyError: "Key not found in the first mapping: 'a'"

>>> # Очистка словаря
>>> alpha_nums.clear()
>>> alpha_nums
ChainMap({}, {'a': 'A', 'b': 'B'})
```

Эти примеры показывают, что операции изменения объекта `ChainMap` влияют только на первый объект во внутреннем списке mapping-объектов. Это важная деталь, которую необходимо учитывать при работе с `ChainMap`.

Сложность заключается в том, что на первый взгляд может показаться, что можно изменить любую существующую пару ключ-значение в данной `ChainMap`. Однако, вы можете изменять только пары ключ-значение в первом mapping-объекте, если вы не используете `.maps` для доступа и изменения других mapping-объектов в списке напрямую.


## UserString, UserList, и UserDict

Иногда вам нужно настроить встроенные типы, такие как строки, списки и словари, чтобы добавить или изменить определенное поведение. Начиная с [Python 2.2](https://docs.python.org/3/whatsnew/2.2.html#peps-252-and-253-type-and-class-changes), вы можете сделать это, создавая подклассы этих типов напрямую. Однако при таком подходе могут возникнуть некоторые проблемы, как вы увидите через минуту.

Python `collections` предоставляет три удобных класса-обертки, которые имитируют поведение встроенных типов данных:

1.  `UserString`
2.  `UserList`
3.  `UserDict`

С помощью комбинации обычных и специальных методов вы можете использовать эти классы для имитации и настройки поведения строк, списков и словарей.

Сегодня разработчики часто спрашивают себя, есть ли смысл использовать `UserString`, `UserList` и `UserDict`, когда им нужно настроить поведение встроенных типов. Ответ - да.

Встроенные типы были [разработаны и реализованы](https://www.youtube.com/watch?v=heJuQWNdwJI) с учетом [принципа открытости-закрытости](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle). Это означает, что они открыты для расширения, но закрыты для модификации. Разрешение модификации основных свойств этих классов потенциально может нарушить их [инварианты](https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science). Поэтому разработчики ядра Python решили защитить их от модификаций.

Например, вам нужен словарь, который автоматически переводит ключи в нижний регистр, когда вы их вставляете. Вы можете создать подкласс `dict` и переопределить [`.__setitem__()`](https://docs.python.org/3/reference/datamodel.html#object.__setitem__), чтобы каждый раз, когда вы вставляете ключ, словарь переводил имя ключа в нижний регистр:
```python
class LowerDict(dict):
...     def __setitem__(self, key, value):
...         key = key.lower()
...         super().__setitem__(key, value)
...

>>> ordinals = LowerDict({"FIRST": 1, "SECOND": 2})
>>> ordinals["THIRD"] = 3
>>> ordinals.update({"FOURTH": 4})

>>> ordinals
{'FIRST': 1, 'SECOND': 2, 'third': 3, 'FOURTH': 4}

>>> isinstance(ordinals, dict)
True
```

Этот словарь работает правильно, когда вы вставляете новые ключи, используя присваивание в стиле словаря с квадратными скобками (`[]`). Однако он не работает, когда вы передаете начальный словарь в [конструктор класса](https://realpython.com/python-class-constructor/) или когда вы используете [`.update()`](https://docs.python.org/3/library/stdtypes.html#dict.update). Это означает, что вам придется переопределить [`.__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__), `.update()` и, возможно, некоторые другие методы, чтобы ваш пользовательский словарь работал правильно.

Теперь посмотрите на тот же словарь, но используя `UserDict` в качестве базового класса:
```python
from collections import UserDict

>>> class LowerDict(UserDict):
...     def __setitem__(self, key, value):
...         key = key.lower()
...         super().__setitem__(key, value)
...

>>> ordinals = LowerDict({"FIRST": 1, "SECOND": 2})
>>> ordinals["THIRD"] = 3
>>> ordinals.update({"FOURTH": 4})

>>> ordinals
{'first': 1, 'second': 2, 'third': 3, 'fourth': 4}

>>> isinstance(ordinals, dict)
False
```

Это работает! Теперь ваш пользовательский словарь преобразует все новые ключи в строчные буквы, прежде чем вставить их в словарь. Обратите внимание, что поскольку вы не наследуете от `dict` напрямую, ваш класс не возвращает экземпляры `dict`, как в примере выше.

`UserDict` хранит обычный словарь в атрибуте экземпляра под названием `.data`. Затем он реализует все свои методы вокруг этого словаря. `UserList` и `UserString` работают аналогичным образом, но их атрибут `.data` содержит объект `list` и `str` соответственно.

Если вам нужно настроить любой из этих классов, то вам просто нужно переопределить соответствующие методы и изменить то, что они делают, по мере необходимости.

В общем, вам следует использовать `UserDict`, `UserList` и `UserString`, когда вам нужен класс, который действует почти идентично базовому обернутому встроенному классу, и вы хотите настроить часть его стандартных функций.

Еще одна причина использовать эти классы вместо встроенных эквивалентных классов - это доступ к базовому атрибуту `.data` для непосредственного манипулирования им.

Возможность прямого наследования от встроенных типов в значительной степени вытеснила использование `UserDict`, `UserList` и `UserString`. Однако внутренняя реализация встроенных типов затрудняет безопасное наследование от них без переписывания значительного объема кода. В большинстве случаев безопаснее использовать соответствующий класс из `collections`. Это избавит вас от ряда проблем и странного поведения.

## Заключение

В модуле Python `collections` есть несколько **специализированных контейнерных типов данных**, которые вы можете использовать для решения общих проблем программирования, таких как подсчет объектов, создание очередей и стеков, обработка отсутствующих ключей в словарях и многое другое.

Типы данных и классы в `collections` были разработаны для того, чтобы быть эффективными и питонскими. Они могут быть очень полезны в вашем пути программирования на Python, поэтому их изучение стоит вашего времени и усилий.

**В этом руководстве вы узнали, как:**

- Писать **читабельный** и **явный** код, используя `namedtuple`.
- Создавать **эффективные очереди** и **стеки** с помощью `deque`
- Эффективно подсчитывать объекты** с помощью `Counter`.
- Обрабатывать **пропущенные ключи словаря** с помощью `defaultdict`.
- Запоминать **порядок вставки** ключей с помощью `OrderedDict`
- **Объединять несколько словарей** в одном представлении с помощью `ChainMap`.

Вы также узнали о трех удобных классах-обертках: `UserDict`, `UserList` и `UserString`. Эти классы удобны, когда вам нужно создать пользовательские классы, имитирующие поведение встроенных типов `dict`, `list` и `str`.