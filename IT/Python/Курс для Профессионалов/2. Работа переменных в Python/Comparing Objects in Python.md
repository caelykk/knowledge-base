[Оригинальная статья на Real Python (eng, 2020)](https://realpython.com/python-is-identity-vs-equality/)

Существует различие между оператором идентичности (`is`) и оператором равенства (`'=='`) в Python.  Когда вы используете оператор `is` для сравнения чисел, ваш Python код может прекрасно работать, пока внезапно [не перестанет](https://medium.com/peloton-engineering/the-dangers-of-using-is-in-python-f42941124027). Возможно, вы где-то слышали, что оператор Python `is` быстрее, чем оператор `'=='`, или вам кажется, что он выглядит более [питонячим](https://realpython.com/tutorials/best-practices/). Однако важно помнить, что эти операторы ведут себя не совсем одинаково.

Оператор `'=='` сравнивает значение или **равенство** двух объектов, тогда как оператор Python `is` проверяет, указывают ли две [переменные](https://realpython.com/python-variables/) на один и тот же объект в памяти. В подавляющем большинстве случаев это означает, что вы должны использовать операторы равенства `'=='` и `!=`, за исключением случаев, когда вы сравниваете с [`None`](https://realpython.com/null-in-python/).

**В этом руководстве вы узнаете:**

- В чем разница между **равенством и идентичностью объектов**
- Когда использовать операторы равенства и идентичности для **сравнения объектов**
- Что эти **операторы Python** делают под капотом
- Почему использование операторов `is` и `is not` для сравнения значений приводит к **неожиданному поведению**
- Как написать **собственный метод класса `__eq__()`** для того, чтобы задать поведение оператора равенства

>**Python Pit Stop:** Этот справочник - **быстрый** и **практичный** способ найти необходимую информацию, так что вы быстро вернетесь к своему проекту!

>**Бесплатный бонус:** [Нажмите здесь, чтобы получить Python Cheat Sheet](https://realpython.com/python-is-identity-vs-equality/) и изучите основы Python 3, такие как работа с типами данных, словарями, списками и функциями Python.

## Сравнение идентичности с помощью операторов Python is и is not

Операторы Python `is` и `is not` сравнивают **идентичность** двух объектов. В [CPython](https://realpython.com/cpython-source-code-guide/) это их адрес в памяти. Все в Python является [объектом](https://realpython.com/courses/intro-object-oriented-programming-oop-python/), и каждый объект хранится в определенном [участке памяти](https://realpython.com/python-memory-management/). Операторы Python `is` и `is not` проверяют, ссылаются ли две переменные на один и тот же объект в памяти.

>**Примечание:** Помните, что объекты с одинаковым значением обычно хранятся по разным адресам памяти.

Вы можете использовать `id()` для проверки идентичности объекта:
```python
help(id)
Help on built-in function id in module builtins:

id(obj, /)
    Return the identity of an object.

    This is guaranteed to be unique among simultaneously existing objects.
    (CPython uses the object's memory address.)

>>> id(id)
2570892442576
```

Последняя строка показывает адрес памяти, где хранится сама встроенная функция `id`.

Есть несколько распространенных случаев, когда объекты с одинаковым значением по умолчанию будут иметь одинаковый id. Например, числа от -5 до 256 в CPython **интернированы**. Каждое число хранится в единственном и фиксированном месте в памяти, что позволяет экономить память для часто используемых целых чисел.

Вы можете использовать `sys.intern()` для [intern](https://docs.python.org/3.7/library/sys.html?highlight=sys.intern#sys.intern) строк для повышения производительности. Эта функция позволяет не сравнивать строки посимвольно, а сравнивать их адреса в памяти:
```python
from sys import intern
>>> a = 'hello world'
>>> b = 'hello world'
>>> a is b
False
>>> id(a)
1603648396784
>>> id(b)
1603648426160

>>> a = intern(a)
>>> b = intern(b)
>>> a is b
True
>>> id(a)
1603648396784
>>> id(b)
1603648396784
```

Переменные `a` и `b` изначально указывают на два разных объекта в памяти, о чем свидетельствуют их разные идентификаторы. Когда вы интернализируете их, вы убеждаетесь, что `a` и `b` указывают на один и тот же объект в памяти. Любая новая [строка](https://realpython.com/python-strings/) со значением `'hello world'` теперь будет создана в новом месте памяти, но когда вы интернируете эту новую строку, вы убедитесь, что она указывает на тот же адрес памяти, что и первая `'hello world'`, которую вы интернировали.

>**Примечание:** Хотя адрес памяти объекта уникален в любой момент времени, он меняется между запусками одного и того же кода, а также зависит от версии CPython и машины, на которой он запущен.

Другими объектами, которые интернируются по умолчанию, являются `None`, `True`, `False` и [simple strings](https://github.com/satwikkansal/wtfpython#-strings-can-be-tricky-sometimes-). Следует помнить, что чаще всего разные объекты с одинаковым значением будут храниться по разным адресам памяти. **Это означает, что вы не должны использовать оператор Python `is` для сравнения значений*.

### Когда интернируются только некоторые целые числа

За кулисами Python интернирует объекты с часто используемыми значениями (например, целые числа от -5 до 256) для [экономии памяти](https://docs.python.org/3/c-api/long.html#c.PyLongObject). Следующий фрагмент кода показывает, как лишь некоторые целые числа имеют фиксированный адрес памяти:
```python
a = 256
>>> b = 256
>>> a is b
True
>>> id(a)
1638894624
>>> id(b)
1638894624

>>> a = 257
>>> b = 257
>>> a is b
False

>>> id(a)
2570926051952
>>> id(b)
2570926051984
```

Изначально `a` и `b` указывают на один и тот же интернированный объект в памяти, но когда их значения выходят за пределы диапазона **обычных целых чисел** (от -5 до 256), они хранятся по разным адресам памяти.


### Когда несколько переменных указывают на один и тот же объект

Когда вы используете оператор присваивания (`'='`), чтобы сделать одну переменную равной другой, вы заставляете эти переменные указывать на один и тот же объект в памяти. Это может привести к неожиданному поведению [изменяемых](https://realpython.com/courses/immutability-python/)  объектов:
```python
a = [1, 2, 3]
>>> b = a
>>> a
[1, 2, 3]
>>> b
[1, 2, 3]

>>> a.append(4)
>>> a
[1, 2, 3, 4]
>>> b
[1, 2, 3, 4]

>>> id(a)
2570926056520
>>> id(b)
2570926056520
```

Что только что произошло? Вы добавили новый элемент в `a`, но теперь `b` тоже содержит этот элемент! В строке, где `b = a`, вы задали `b` тот же адрес памяти, что и `a`, так что обе переменные теперь ссылаются на один и тот же объект.

Если вы объявите эти [списки](https://realpython.com/courses/lists-tuples-python/) независимо друг от друга, то они будут храниться по разным адресам памяти и вести себя независимо:
```python
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
>>> id(a)
2356388925576
>>> id(b)
2356388952648
```

Поскольку `a` и `b` теперь ссылаются на разные объекты в памяти, изменение одного не влияет на другой.

## Сравнение равенства с помощью операторов Python == и !=

Вспомните, что объекты с **одинаковым значением** часто хранятся по **разным адресам памяти**. Используйте операторы равенства `'=='` и `!=`, если вы хотите проверить, имеют ли два объекта одинаковое значение, независимо от того, где они хранятся в памяти. В подавляющем большинстве случаев это то, что вы хотите сделать.

### Когда копия объекта равна, но не идентична

В примере ниже вы задаете `b` как копию `a` (которая является изменяемым объектом, таким как [list](https://realpython.com/python-lists-tuples/) или [dictionary](https://realpython.com/python-dicts/)). Обе переменные будут иметь одно и то же значение, но каждая будет храниться по разным адресам памяти:
```python
>>> a = [1, 2, 3]
>>> b = a.copy()
>>> a
[1, 2, 3]
>>> b
[1, 2, 3]

>>> a == b
True
>>> a is b
False

>>> id(a)
2570926058312
>>> id(b)
2570926057736
```

Теперь `a` и `b` хранятся по разным адресам памяти, поэтому `a is b` больше не будет возвращать `True`. Однако, `a == b` возвращает `True`, потому что оба объекта имеют одинаковое значение.

### Как работает сравнение по равенству

Магия оператора равенства `'=='` происходит в методе класса `__eq__()` объекта, расположенного слева от знака `'=='`.

**Примечание:** Это происходит, если объект справа не является **подклассом** объекта слева. За дополнительной информацией обратитесь к официальной [документации](https://docs.python.org/3/reference/datamodel.html#object.__eq__).

Это [магический метод класса](https://realpython.com/operator-function-overloading/), который вызывается всякий раз, когда экземпляр этого класса сравнивается с другим объектом. Если этот метод не реализован, то `'=='` по умолчанию сравнивает адреса памяти двух объектов.

В качестве упражнения создайте класс `SillyString`, который наследуется от `str`, и реализуйте `__eq__()` для сравнения того, совпадает ли длина этой строки с длиной другого объекта:
```python
class SillyString(str):
    # Этот метод вызывается при использовании == на объекте
    def __eq__(self, other):
        print(f'comparing {self} to {other}')
        # Возвращает True, если self и other имеют одинаковую длину
        return len(self) == len(other)    
```

Теперь SillyString `'hello world'` должна быть равна строке `'world hello'`, и даже любому другому объекту с такой же длиной:
```python
# Сравнение двух строк
>>> 'hello world' == 'world hello'
False

>>> # Сравнение строки с SillyString
>>> 'hello world' == SillyString('world hello')
comparing world hello to hello world
True

>>> # Сравнение строки SillyString со списком
>>> SillyString('hello world') == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
comparing hello world to [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
True
```

Это, конечно, глупое поведение для объекта, который в остальном ведет себя как строка, но оно иллюстрирует, что происходит, когда вы сравниваете два объекта с помощью `'=='`. Оператор `!=` дает противоположный результат, если только не реализован специальный метод класса `__ne__()`.

Приведенный пример также наглядно показывает, почему для сравнения с `None` лучше использовать оператор Python `is`, а не оператор `'=='`. Он не только быстрее, поскольку сравнивает адреса памяти, но и безопаснее, поскольку не зависит от логики методов класса `__eq__()`.

## Сравнение операторов сравнения Python

Как правило, вы всегда должны использовать операторы равенства `'=='` и `!=`, за исключением случаев, когда вы сравниваете с `None`:

- **Используйте операторы Python `'=='` и `!=` для сравнения равенства объектов**. В данном случае вы обычно сравниваете значение двух объектов. Это то, что вам нужно, если вы хотите сравнить, имеют ли два объекта одинаковое содержимое, и вам не важно, где они хранятся в памяти.
    
- **Используйте операторы Python `is` и `is not`, когда вы хотите сравнить идентичность объектов**. В данном случае вы сравниваете, указывают ли две переменные на один и тот же объект в памяти. Основным вариантом использования этих операторов является сравнение с `None`. Сравнивать с `None` по адресу памяти быстрее и безопаснее, чем с помощью методов класса.
    

Переменные с одинаковым значением часто хранятся по разным адресам памяти. Это означает, что вы должны использовать `'=='` и `!=` для сравнения их значений и использовать операторы Python `is` и `is not` только тогда, когда вы хотите проверить, указывают ли две переменные на один и тот же адрес памяти.

## Заключение

В этом руководстве вы узнали, что `'=='` и `!=` **сравнивают значения двух объектов**, в то время как операторы Python `is` и `is not` сравнивают, ссылаются ли две переменные **на один и тот же объект в памяти**. Если вы будете помнить об этом различии, то сможете предотвратить неожиданное поведение вашей программы.

Если вы хотите узнать больше об удивительном мире **объектных интернирований** и операторе Python `is`, ознакомьтесь с [Why you should almost never use "is" in Python](https://lerner.co.il/2015/06/16/why-you-should-almost-never-use-is-in-python/). Вы также можете изучить, как можно использовать `sys.intern()` для оптимизации использования памяти и времени сравнения строк, хотя есть вероятность, что Python уже автоматически делает это за вас.

Теперь, когда вы узнали, что делают операторы **сравнения и идентичности**, вы можете попробовать написать свои собственные методы класса `__eq__()`, которые определяют, как сравниваются экземпляры этого класса при использовании оператора `'=='`. Применяйте свои новые знания об этих операторах сравнения в Python!