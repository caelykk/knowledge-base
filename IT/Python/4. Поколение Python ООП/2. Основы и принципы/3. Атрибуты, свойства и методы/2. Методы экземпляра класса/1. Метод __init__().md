## Метод `__init__()`

Рассмотрим следующее определение класса `Cat`:

```python
class Cat:
    pass
```

После создания экземпляра данного класса мы получаем объект, у которого нет никаких атрибутов. И если нам требуется, чтобы объект ими обладал, нам приходится определять их вручную для каждого объекта, либо определять атрибуты на уровне класса. Очевидно, оба способа имеют свои недостатки, так как в первом случае нам приходится определять каждый атрибут для каждого объекта, во втором случае — все экземпляры класса имеют атрибуты с одними и теми же значениями, что не всегда нужно. Решить данную проблему позволяет специальный метод `__init__()`.

Метод `__init__()` называют **методом инициализации** или **инициализатором**.

Метод `__init__()` инициализирует атрибуты объекта. 

Сразу после создания объекта исполняется метод `__init__()`, и параметру `self` автоматически присваивается объект, который был только что создан, что позволяет тут же наделить его необходимыми атрибутами.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed                       # порода кошки
        self.name = name                         # имя кошки


cat = Cat('Британский', 'Кемаль')
```
создает экземпляр класса `Cat`, который имеет атрибуты `breed` и `name` со значениями `Британский` и `Кемаль` соответственно.

![[Pasted image 20240522170817.png]]

Важно уточнить, что метод `__init__()` исполняется после создания каждого экземпляра класса `Cat`, поэтому каждый объект будет иметь те значения атрибутов, которые были указаны при его создании.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat('Манчкин', 'Роджер')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
```

выводит:
```python
Британский Кемаль
Манчкин Роджер
```

Поскольку мы определили параметры `breed` и `name` для метода `__init__()`, они должны быть явно переданы при создании новых экземпляров класса `Cat`.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat = Cat()
```
приводит к возбуждению исключения:
```python
TypeError: Cat.__init__() missing 2 required positional arguments: 'breed' and 'name'
```

Однако если мы хотим, чтобы при создании объекта значения некоторых атрибутов можно было не указывать, мы можем установить им значения по умолчанию.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, breed, name=None):
        self.breed = breed
        self.name = name


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat('Манчкин')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
```
выводит:
```python
Британский Кемаль
Манчкин None
```

Сигнатура метода `__init__()` полностью повторяет сигнатуру любой функции. С помощью `*args` и `**kwargs` метод `__init__()` может принимать произвольное количество позиционных и именованных аргументов соответственно.

Помимо значений аргументов, передаваемых в инициализатор, атрибутам можно устанавливать некоторые фиксированные значения.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name
        self.night_vision = True                 # способность видеть в темноте


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat('Манчкин', 'Роджер')

print(cat1.night_vision)
print(cat2.night_vision)
```
выводит:
```python
True
True
```

### Примечания
#### Примечание 1.
Можно подумать, что метод `__init__()` отвечает за создание экземпляров класса, но это не так, он принимает в качестве аргумента уже созданный классом объект и инициализирует его.

#### **Примечание 2.** 
Возвращаемым значением метода `__init__()` должно быть значение `None`,  в противном случае будет возбуждено исключение.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name
        return self


cat = Cat('Британский', 'Кемаль')
```
приводит к возбуждению исключения:
```python
TypeError: __init__() should return None, not 'Cat'
```

#### **Примечание 3.** 
Класс может иметь только один инициализатор. При попытке определить в классе два инициализатора, предыдущий будет заменен следующим.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat = Cat('Британский', 'Кемаль')

print(cat.breed)
print(cat.name)
```
выводит:
```python
Британский
Кемаль
```