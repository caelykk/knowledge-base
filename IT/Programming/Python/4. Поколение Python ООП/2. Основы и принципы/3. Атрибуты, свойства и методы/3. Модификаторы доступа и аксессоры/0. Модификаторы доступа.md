## Модификаторы доступа

Доступ к атрибутам объекта должны иметь только методы этого объекта. Такой подход защищает атрибуты от случайного повреждения.

В классических языках программирования (C++, Java, C#) доступ к атрибутам реализуется с помощью ключевых слов:
- `protected` (*защищенный*) - доступ к защищенным атрибутам возможен только внутри этого класса, а также внутри унаследованных от него классов
- `private` (*приватный*) - приватные атрибуты недоступны извне — с ними можно работать только внутри этого класса
- `public` (*публичный*) - публичные атрибуты доступны для работы снаружи

С точки зрения разграничения доступа к атрибутам Python является особенным языком — в нем отсутствует механизм, который мог бы запретить внешнему коду взаимодействовать с атрибутами объекта или класса. Вместо этого создатели Python предложили следующий ряд соглашений:
- если имя атрибута начинается с одного нижнего подчеркивания (`_name`), то он считается **`защищенным`**
- если имя атрибута начинается с двух нижних подчеркиваний (`__name`), то он считается **`приватным`**

В Python все атрибуты являются публичными по умолчанию. Любой атрибут объекта может быть доступен за пределами класса, независимо от того, является он публичным, защищенным или приватным.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)
```
выводит:
```python
Кемаль
Роджер
```
Аналогичное поведение наблюдается и с защищенными атрибутами, то есть атрибутами, имя которых начинается с одного символа нижнего подчеркивания.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, name):
        self._name = name


cat = Cat('Кемаль')
print(cat._name)

cat._name = 'Роджер'
print(cat._name)
```
выводит:
```python
Кемаль
Роджер
```

Иными словами, это больше вопрос ответственности программиста — он не должен работать за пределами класса с атрибутами, имена которых начинаются с нижнего подчёркивания.

Несколько иначе себя ведут приватные атрибуты. Если мы предварим имя атрибута двумя нижними подчеркиваниями, то есть сделаем его приватным, то код за пределами класса не сможет получить к нему доступ напрямую.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__name)
```
приводит к возбуждению исключения:
```python
AttributeError: 'Cat' object has no attribute '__name'
```

Может показаться, что для внешнего кода приватного атрибута действительно не существует, однако если мы посмотрим на содержимое словаря атрибутов объекта, то увидим, что на самом деле приватный атрибут лишь получил другое имя.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__dict__)
```
выводит: 
```python
{'_Cat__name': 'Кемаль'}
```

Дело в том, что, делая атрибут приватным, на самом деле мы лишь неявно изменяем его имя. Такое поведение называется **<font color="#ebd96c">искажением имени</font>**.

Любой атрибут вида `__name` текстуально заменяется на `_class__name`, где `class` — это имя текущего класса.

Таким образом, возможность обратиться к приватному атрибуту, а также изменить его значение все же остается.

Приведенный ниже код:
```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

cat._Cat__name = 'Роджер'

print(cat.__dict__)
```
выводит:
```python
{'_Cat__name': 'Роджер'}
```

## Примечания

### **Примечание 1.** 
Хорошая статья про именование с подчеркиванием в Python доступна по [ссылке](https://django.fun/ru/articles/python/naming-underscores-python/).

### **Примечание 2.** 
Физически механизм ограничения доступа к атрибутам в Python реализован слабо, лишь на уровне соглашения, поэтому ответственность за соблюдение данного соглашения ложится на плечи программистов.

### **Примечание 3.** 
Искажение имени приватного атрибута происходит лишь при его установке внутри класса. 

Приведенный ниже код:
```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

cat.__age = 1

print(cat.__dict__)
```
выводит:
```python
{'_Cat__name': 'Кемаль', '__age': 1}
```