[Оригинальная статья (eng)](https://realpython.com/working-with-files-in-python/)

## Шаблон "with open(...) as ..." 

Чтение и запись данных в файлы с помощью Python довольно просты. Для этого необходимо сначала открыть файлы в соответствующем режиме. Вот пример использования шаблона Python "with open(...) as ..." для открытия текстового файла и чтения его содержимого:
```python
with open('data.txt', 'r') as f:
    data = f.read()
```

`open()` принимает в качестве аргументов имя файла и режим. `r` открывает файл в режиме только для чтения. Чтобы записать данные в файл, передайте в качестве аргумента `w`:
```python
with open('data.txt', 'w') as f:
    data = 'some data to be written to the file'
    f.write(data)
```

В приведенных выше примерах `open()` открывает файлы для чтения или записи и возвращает дескриптор файла (в данном случае `f`), который предоставляет методы, которые можно использовать для чтения или записи данных в файл. Смотрите дополнительную информацию о [чтении и записи файлов в Python](https://realpython.com/read-write-files-python/) и [работе с файловым вводом-выводом в Python](https://dbader.org/blog/python-file-io) .


## Получение списка каталогов

Предположим, что в вашем текущем рабочем каталоге есть подкаталог my_directory, который имеет следующее содержимое:
```
my_directory/
|
├── sub_dir/
|   ├── bar.py
|   └── foo.py
|
├── sub_dir_b/
|   └── file4.txt
|
├── sub_dir_c/
|   ├── config.py
|   └── file5.txt
|
├── file1.py
├── file2.csv
└── file3.txt
```

Встроенный модуль `os` имеет ряд полезных функций, которые можно использовать для перечисления содержимого каталогов и фильтрации результатов. Чтобы получить список всех файлов и папок в определенном каталоге файловой системы, используйте `os.listdir()` в устаревших версиях Python или `os.scandir()` в Python 3.x. `os.scandir()` - предпочтительный метод, если вы также хотите получить свойства файлов и каталогов, такие как размер файла и дата модификации.

### Получение списка каталогов в устаревших версиях Python

В версиях Python, предшествующих Python 3, `os.listdir()` - это метод, который следует использовать для получения списка каталогов:
```python
>>> import os
>>> entries = os.listdir('my_directory/')
```

`os.listdir()` возвращает список Python, содержащий имена файлов и подкаталогов в каталоге, заданном аргументом `path`:
```python
>>> os.listdir('my_directory/')
['sub_dir_c', 'file1.py', 'sub_dir_b', 'file3.txt', 'file2.csv', 'sub_dir']
```
Такой список каталогов нелегко читать. Вывод результата вызова `os.listdir()` с помощью цикла помогает навести порядок:
```python
>>> entries = os.listdir('my_directory/')
>>> for entry in entries:
...     print(entry)
...
...
sub_dir_c
file1.py
sub_dir_b
file3.txt
file2.csv
sub_dir
```


### Получение списка каталогов в современных версиях Python

В современных версиях Python альтернативой `os.listdir()` является использование `os.scandir(`) и` pathlib.Path()`.

`os.scandir()` была введена в Python 3.5 и документирована в PEP 471. `os.scandir()` при вызове возвращает итератор, а не список:
```python
>>> import os
>>> entries = os.scandir('my_directory/')
>>> entries
<posix.ScandirIterator object at 0x7f5b047f3690>
```

Итератор `ScandirIterator` указывает на все записи в текущем каталоге. Вы можете перебрать содержимое итератора и вывести имена файлов:
```python
import os

with os.scandir('my_directory/') as entries:
    for entry in entries:
        print(entry.name)
```

Здесь `os.scandir()` используется в сочетании с оператором `with`, поскольку он поддерживает протокол контекстного менеджера. Использование менеджера контекста закрывает итератор и освобождает приобретенные ресурсы автоматически после исчерпания итератора. В результате вы получите распечатку имен файлов в `my_directory/` точно так же, как вы видели в примере `os.listdir()`:
```shell
sub_dir_c
file1.py
sub_dir_b
file3.txt
file2.csv
sub_dir
```

Другой способ получить список каталогов - использовать модуль `pathlib`:
```python
from pathlib import Path

entries = Path('my_directory/')
for entry in entries.iterdir():
	print(entry.name)
```

Объекты, возвращаемые `Path`, являются объектами `PosixPath` или `WindowsPath` в зависимости от ОС.

Объекты `pathlib.Path()` имеют метод `.iterdir()` для создания [итератора всех файлов и папок в каталоге](https://realpython.com/get-all-files-in-directory-python/). Каждая запись, полученная методом `.iterdir()`, содержит информацию о файле или каталоге, такую как его имя и атрибуты файла. `pathlib` был впервые представлен в Python 3.4 и является отличным дополнением к Python, предоставляющим объектно-ориентированный интерфейс к файловой системе.

В приведенном выше примере вы вызываете `pathlib.Path()` и передаете ей аргумент path. Далее следует вызов `.iterdir()` для получения списка всех файлов и каталогов в `my_directory`.

`pathlib` предлагает набор классов, в которых в простой объектно-ориентированной форме представлено большинство распространенных операций над путями. Использование `pathlib` более эффективно, если не столь же эффективно, как использование функций в `os`. Еще одним преимуществом использования `pathlib` перед `os` является уменьшение количества импортов, которые необходимо сделать для работы с путями файловой системы. Для получения дополнительной информации читайте [Python 3's pathlib Module: Taming the File System](https://realpython.com/python-pathlib/).

>**Примечание:** Чтобы начать работу с `pathlib`, ознакомьтесь с [Основы Python: Операции с файловой системой](https://realpython.com/courses/python-basics-file-system-operations/).

Выполнение приведенного выше кода дает следующее:
```shell
sub_dir_c
file1.py
sub_dir_b
file3.txt
file2.csv
sub_dir
```

Использование `pathlib.Path()` или `os.scandir()` вместо `os.listdir()` является предпочтительным способом получения списка каталогов, особенно когда вы работаете с кодом, которому требуется информация о типе и атрибутах файла. `pathlib.Path()` предлагает большую часть функциональности по работе с файлами и путями, которая есть в `os` и `shutil`, и его методы более эффективны, чем некоторые из этих модулей. В ближайшее время мы обсудим, как получить свойства файла.

Здесь снова представлены функции для работы со списками каталогов:

Функция | Описание
-- | --
`os.listdir()` | Возвращает список всех файлов и папок в каталоге
`os.scandir()` | Возвращает итератор всех объектов в каталоге, включая информацию об атрибутах файлов.
`pathlib.Path.iterdir()` | Возвращает итератор всех объектов в каталоге, включая информацию об атрибутах файлов.

Эти функции возвращают список _всего_ в каталоге, включая подкаталоги. Это не всегда то поведение, которое вам нужно. В следующем разделе будет показано, как отфильтровать результаты из списка каталогов.

### Вывод списка всех файлов в каталоге

В этом разделе будет показано, как вывести имена файлов в каталоге с помощью `os.listdir()`, `os.scandir()` и `pathlib.Path()`. Чтобы отфильтровать каталоги и вывести только файлы из списка каталогов, полученного с помощью `os.listdir()`, используйте `os.path`:
```python
import os

# List all files in a directory using os.listdir
basepath = 'my_directory/'
for entry in os.listdir(basepath):
    if os.path.isfile(os.path.join(basepath, entry)):
        print(entry)
```

Здесь вызов `os.listdir()` возвращает список всего, что находится в указанном пути, а затем этот список фильтруется `os.path.isfile()`, чтобы вывести только файлы, а не каталоги. В результате получается следующий результат:
```shell
file1.py
file3.txt
file2.csv
```
Более простой способ перечислить файлы в каталоге - использовать `os.scandir()` или `pathlib.Path()`:

```python
import os

# List all files in a directory using scandir()
basepath = 'my_directory/'
with os.scandir(basepath) as entries:
    for entry in entries:
        if entry.is_file():
            print(entry.name)
```

Использование `os.scandir()` имеет то преимущество, что выглядит чище и проще для понимания, чем использование `os.listdir()`, хотя это на одну строку кода длиннее. Вызов `entry.is_file()` для каждого элемента в `ScandirIterator` возвращает `True`, если объект является файлом. Распечатка имен всех файлов в каталоге дает следующий результат:
```shell
file1.py
file3.txt
file2.csv
```

Вот как перечислить файлы в каталоге с помощью `pathlib.Path()`:
```python
from pathlib import Path

basepath = Path('my_directory/')
files_in_basepath = basepath.iterdir()
for item in files_in_basepath:
    if item.is_file():
        print(item.name)
```

Здесь вы вызываете `.is_file()` для каждой записи, полученной `.iterdir()`. Вывод будет таким же:
```shell
file1.py
file3.txt
file2.csv
```

Приведенный выше код можно сделать более кратким, если объединить [цикл `for`](https://realpython.com/python-for-loop/) и [оператор `if`](https://realpython.com/python-conditional-statements/) в одно генераторное выражение. У Дэна Бадера есть [отличная статья](https://dbader.org/blog/python-generator-expressions) о [генераторных выражениях](https://realpython.com/introduction-to-python-generators/) и понимании списков.

Модифицированная версия выглядит следующим образом:
```python
from pathlib import Path

# List all files in directory using pathlib
basepath = Path('my_directory/')
files_in_basepath = (entry for entry in basepath.iterdir() if entry.is_file())
for item in files_in_basepath:
    print(item.name)
```

Это дает точно такой же результат, как и предыдущий пример. Этот раздел показал, что фильтрация файлов или каталогов с помощью `os.scandir()` и `pathlib.Path()` более интуитивна и выглядит чище, чем использование `os.listdir()` в сочетании с `os.path`.

### Вывод списка подкаталогов

Чтобы перечислить подкаталоги вместо файлов, используйте один из приведенных ниже методов. Вот как использовать `os.listdir()` и `os.path()`:
```python
import os

# List all subdirectories using os.listdir
basepath = 'my_directory/'
for entry in os.listdir(basepath):
    if os.path.isdir(os.path.join(basepath, entry)):
        print(entry)
```

Манипулирование путями файловой системы таким образом может быстро стать громоздким, если у вас есть несколько вызовов `os.path.join()`. Запуск этой программы на моем компьютере приводит к следующему результату:
```shell
sub_dir_c
sub_dir_b
sub_dir
```

Вот как можно использовать `os.scandir()`:
```python
import os

# List all subdirectories using scandir()
basepath = 'my_directory/'
with os.scandir(basepath) as entries:
    for entry in entries:
        if entry.is_dir():
            print(entry.name)
```

Как и в примере с листингом файлов, здесь вы вызываете `.is_dir()` для каждой записи, возвращенной `os.scandir()`. Если запись является каталогом, `.is_dir()` возвращает `True`, и имя каталога выводится на печать. Вывод такой же, как и выше:
```shell
sub_dir_c
sub_dir_b
sub_dir
```

Вот как можно использовать `pathlib.Path()`:
```python
from pathlib import Path

# List all subdirectory using pathlib
basepath = Path('my_directory/')
for entry in basepath.iterdir():
    if entry.is_dir():
        print(entry.name)
```

Вызов `.is_dir()` на каждом элементе итератора `basepath` проверяет, является ли элемент файлом или каталогом. Если элемент является каталогом, то его имя выводится на экран, а полученный результат совпадает с результатом предыдущего примера:
```shell
sub_dir_c
sub_dir_b
sub_dir
```

## Получение атрибутов файла

Python позволяет легко получить атрибуты файла, такие как его размер и время изменения. Это делается с помощью `os.stat()`, `os.scandir()` или `pathlib.Path()`.

`os.scandir()` и `pathlib.Path()` получают список каталогов с объединенными атрибутами файлов. Это может быть потенциально более эффективно, чем использование `os.listdir()` для перечисления файлов и последующего получения информации об атрибутах файлов для каждого файла.

Примеры ниже показывают, как получить время последнего изменения файлов в `my_directory/`. Данные выводятся в секундах:
```python
>>> import os
>>> with os.scandir('my_directory/') as dir_contents:
...     for entry in dir_contents:
...         info = entry.stat()
...         print(info.st_mtime)
...
1539032199.0052035
1539032469.6324475
1538998552.2402923
1540233322.4009316
1537192240.0497339
1540266380.3434134
```

`os.scandir()` возвращает объект `ScandirIterator`. Каждый элемент объекта `ScandirIterator` имеет метод `.stat()`, который извлекает информацию о файле или каталоге, на который он указывает. Метод `.stat()` предоставляет такую информацию, как размер файла и время последней модификации. В приведенном выше примере код выводит атрибут `st_mtime`, который является временем последнего изменения содержимого файла.

Модуль `pathlib` располагает соответствующими методами для получения информации о файлах, которые дают такие же результаты:
```python
>>> from pathlib import Path
>>> current_dir = Path('my_directory')
>>> for path in current_dir.iterdir():
...     info = path.stat()
...     print(info.st_mtime)
...
1539032199.0052035
1539032469.6324475
1538998552.2402923
1540233322.4009316
1537192240.0497339
1540266380.3434134
```

В приведенном выше примере код циклически проходит через объект, возвращенный `.iterdir()`, и извлекает атрибуты файла через вызов `.stat()` для каждого файла в списке каталогов. Атрибут `st_mtime` возвращает float значение, которое представляет [секунды с момента эпохи](https://en.wikipedia.org/wiki/Epoch_(reference_date)#Computing). Чтобы преобразовать значения, возвращаемые `st_mtime` для отображения, можно написать вспомогательную функцию для преобразования секунд в объект `datetime`:
```python
from datetime import datetime
from os import scandir

def convert_date(timestamp):
    d = datetime.utcfromtimestamp(timestamp)
    formated_date = d.strftime('%d %b %Y')
    return formated_date

def get_files():
    dir_entries = scandir('my_directory/')
    for entry in dir_entries:
        if entry.is_file():
            info = entry.stat()
            print(f'{entry.name}\t Last Modified: {convert_date(info.st_mtime)}')
```

Сначала будет получен список файлов в `my_directory` и их атрибуты, а затем вызывается `convert_date()` для преобразования времени последнего изменения каждого файла в удобочитаемую форму. `convert_date()` использует `.strftime()` для преобразования времени в секундах в строку.

Аргументы, передаваемые в `.strftime()`, будут следующими:

- **`%d`:** день месяца
- **`%b`:** месяц в сокращенном виде
- **`%Y`:** год.

Вместе эти команды дают результат, который выглядит следующим образом:
```python
>>> get_files()
file1.py        Last modified:  04 Oct 2018
file3.txt       Last modified:  17 Sep 2018
file2.txt       Last modified:  17 Sep 2018
```

Синтаксис преобразования дат и времени в строки может быть довольно запутанным. Чтобы узнать об этом больше, ознакомьтесь с [официальной документацией](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) по этой теме. Еще одна удобная ссылка, которую легко запомнить, - [http://strftime.org/](http://strftime.org/) .

## Создание каталогов

Рано или поздно программы, которые вы пишете, должны будут создавать каталоги, чтобы хранить в них данные. `os` и `pathlib` предоставляют функции для создания каталогов. Рассмотрим их:
Функция | Описание
-- | --
`os.mkdir()` | Создает один подкаталог
`pathlib.Path.mkdir()` | Создает один или несколько каталогов
`os.makedirs()` | Создает несколько каталогов, включая промежуточные каталоги

### Создание одиночного каталога

Чтобы создать один каталог, укажите путь к каталогу в качестве параметра в `os.mkdir()`:
```python
import os

os.mkdir('example_directory/')
```

Если путь уже существует, `mkdir()` вызовет `FilExistsError`:
```python
>>> p.mkdir()
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
  File '/usr/lib/python3.5/pathlib.py', line 1214, in mkdir
    self._accessor.mkdir(self, mode)
  File '/usr/lib/python3.5/pathlib.py', line 371, in wrapped
    return strfunc(str(pathobj), *args)
FileExistsError: [Errno 17] File exists: '.'
[Errno 17] File exists: '.'
```

Чтобы избежать подобных ошибок, [перехватите ошибку](https://realpython.com/python-exceptions/), когда она возникнет, и сообщите об этом пользователю:
```python
from pathlib import Path

p = Path('example_directory')
try:
    p.mkdir()
except FileExistsError as exc:
    print(exc)
```

В качестве альтернативы, вы можете игнорировать `FileExistsError`, передав аргумент `exist_ok=True` в `.mkdir()`:
```python
from pathlib import Path

p = Path('example_directory')
p.mkdir(exist_ok=True)
```

Это не вызовет ошибку, если каталог уже существует.

### Создание нескольких каталогов

`os.makedirs()` аналогична `os.mkdir()`. Разница между ними в том, что `os.makedirs()` может не только создавать отдельные каталоги, но и создавать деревья каталогов. Другими словами, он может создавать любые требуемые промежуточные папки, чтобы обеспечить наличие полного пути.

Функция `os.makedirs()` аналогична запуску `mkdir -p` в Bash. Например, чтобы создать группу каталогов наподобие `2018/10/05`, достаточно сделать следующее:
```python
import os


os.makedirs('2018/10/05')
```

Это создаст вложенную структуру каталогов, содержащую папки 2018, 10 и 05:
```
.
|
└── 2018/
    └── 10/
        └── 05/
```

`.makedirs()` создает каталоги с правами по умолчанию. Если вам нужно создать каталоги с другими правами, вызовите `.makedirs()` и укажите режим, в котором вы хотите, чтобы каталоги были созданы:
```python
import os

os.makedirs('2018/10/05', mode=0o770)
```
Это создает структуру каталогов `2018/10/05` и предоставляет владельцу и группе пользователей права на чтение, запись и выполнение. Режим по умолчанию - `0o777`, и биты прав доступа к файлам существующих родительских каталогов не изменяются. Более подробную информацию о правах доступа к файлам и о том, как применяется режим, [см. в документации](https://docs.python.org/3/library/os.html#os.makedirs).

Запустите `tree`, чтобы убедиться, что были применены правильные разрешения:
```shell
$ tree -p -i .
.
[drwxrwx---]  2018
[drwxrwx---]  10
[drwxrwx---]  05
```

Выводит древо каталогов текущего каталога. `tree` обычно используется для вывода списка содержимого каталогов в древовидном формате. Передача аргументов `-p` и `-i` выводит имена каталогов и информацию о разрешениях файлов в виде вертикального списка. `-p` выводит права доступа к файлам, `-i` заставляет `tree` выводить вертикальный список без отступов.

Как вы можете видеть, все каталоги имеют разрешения `770`. Альтернативным способом создания каталогов является использование `.mkdir()` из `pathlib.Path`:
```python
import pathlib

p = pathlib.Path('2018/10/05')
p.mkdir(parents=True)
```

Передача `parents=True` в `Path.mkdir()` заставляет его создать каталог `05` и все родительские каталоги, необходимые для того, чтобы путь был действующим.

По умолчанию `os.makedirs()` и `Path.mkdir()` вызывают ошибку `OSError`, если целевой каталог уже существует. Это поведение можно отменить (начиная с Python 3.2), передав `exist_ok=True` в качестве ключевого аргумента при вызове каждой функции.

Выполнение приведенного выше кода позволяет получить структуру каталогов, как показано ниже:
```
.
|
└── 2018/
    └── 10/
        └── 05/
```

Я предпочитаю использовать `pathlib` при создании каталогов, потому что я могу использовать одну и ту же функцию для создания одиночных или вложенных каталогов.

## Шаблонный поиск имен файлов

После получения списка файлов в каталоге с помощью одного из описанных выше методов, вы, скорее всего, захотите найти файлы, соответствующие определенному шаблону.

Для этого существуют следующие методы и функции:

-   строковые методы `endswith()` и `startswith()` 
-   `fnmatch.fnmatch()`
-   `glob.glob()`
-   `pathlib.Path.glob()`

Каждый из них рассматривается ниже. Примеры в этом разделе будут выполняться в каталоге с названием `some_directory`, который имеет следующую структуру:
```
.
|
├── sub_dir/
|   ├── file1.py
|   └── file2.py
|
├── admin.py
├── data_01_backup.txt
├── data_01.txt
├── data_02_backup.txt
├── data_02.txt
├── data_03_backup.txt
├── data_03.txt
└── tests.py
```

Если вы используете оболочку Bash, вы можете создать вышеуказанную структуру каталогов с помощью следующих команд:
```bash
$ mkdir some_directory
$ cd some_directory/
$ mkdir sub_dir
$ touch sub_dir/file1.py sub_dir/file2.py
$ touch data_{01..03}.txt data_{01..03}_backup.txt admin.py tests.py
```
Это создаст каталог `some_directory/`, перейдет в него, а затем создаст `sub_dir`. Следующая строка создает `file1.py` и `file2.py` в `sub_dir`, а последняя строка создает все остальные файлы с помощью расширения. Чтобы узнать больше о расширении оболочки, посетите [этот сайт](http://linuxcommand.org/lc3_lts0080.php).

### Использование строковых методов

В Python есть несколько встроенных методов для модификации и манипулирования строками (https://realpython.com/python-strings/). Два из этих методов, `.startswith()` и `.endswith()`, полезны при поиске шаблонов в именах файлов. Для этого сначала получите список каталогов, а затем выполните итерацию по нему:
```python
>>> import os

>>> # Get .txt files
>>> for f_name in os.listdir('some_directory'):
...     if f_name.endswith('.txt'):
...         print(f_name)
```

Приведенный выше код находит все файлы в `some_directory/`, перебирает их и использует `.endswith()` для вывода имен файлов, имеющих расширение `.txt`. Запуск этой программы на моем компьютере дает следующий результат:
```shell
data_01.txt
data_03.txt
data_03_backup.txt
data_02_backup.txt
data_02.txt
data_01_backup.txt
```

### Простое сопоставление шаблонов имен файлов с помощью `fnmatch`.

Строковые методы ограничены в своих возможностях сопоставления. В `fnmatch` есть более продвинутые функции и методы для поиска шаблонов. Мы рассмотрим `fnmatch.fnmatch()`, функцию, которая поддерживает использование подстановочных символов, таких как `*` и `?` для поиска имен файлов. Например, чтобы найти все файлы `.txt` в каталоге с помощью `fnmatch`, нужно сделать следующее:
```python
>>> import os
>>> import fnmatch

>>> for file_name in os.listdir('some_directory/'):
...     if fnmatch.fnmatch(file_name, '*.txt'):
...         print(file_name)
```

Здесь выполняется итерация по списку файлов в `some_directory` и используется `.fnmatch()` для поиска файлов с расширением `.txt`.

### Более продвинутый поиск по шаблону

Предположим, вы хотите найти файлы `.txt`, которые соответствуют определенным критериям. Например, вы можете быть заинтересованы в поиске только тех файлов `.txt`, которые содержат слово `data`, число между символами подчеркивания и слово `backup` в своем имени. Что-то вроде `data_01_backup`, `data_02_backup` или `data_03_backup`.

Используя `fnmatch.fnmatch()`, вы можете сделать это следующим образом:
```python
>>> for filename in os.listdir('.'):
...     if fnmatch.fnmatch(filename, 'data_*_backup.txt'):
...         print(filename)
```

Здесь вы выводите только имена файлов, которые соответствуют шаблону `data_*_backup.txt`. Звездочка в шаблоне будет соответствовать любому символу, поэтому при выполнении этой команды будут найдены все текстовые файлы, имена которых начинаются со слова `data` и заканчиваются `backup.txt`, как видно из приведенного ниже результата:
```shell
data_03_backup.txt
data_02_backup.txt
data_01_backup.txt
```

### Сопоставление шаблонов имен файлов с помощью `glob`

Еще одним полезным модулем для поиска шаблонов является `glob`.

`.glob()` в модуле `glob` работает так же, как `fnmatch.fnmatch()`, но в отличие от `fnmatch.fnmatch()`, он рассматривает файлы, начинающиеся с точки (`.`), как специальные.

UNIX и родственные системы преобразуют шаблоны имен с подстановочными знаками типа `?` и `*` в список файлов. Это называется globbing.

Например, ввод `mv *.py python_files/` в оболочке UNIX перемещает (`mv`) все файлы с расширением `.py` из текущего каталога в каталог `python_files`. Символ `*` - это подстановочный знак, означающий "любое количество символов", а `*.py` - это шаблон glob. Эта возможность оболочки недоступна в операционной системе Windows. Модуль `glob` добавляет эту возможность в Python, что позволяет программам Windows использовать эту возможность.

Вот пример использования `glob` для поиска всех исходных файлов Python (`.py`) в текущем каталоге directory:
```python
>>> import glob
>>> glob.glob('*.py')
['admin.py', 'tests.py']
```

`glob.glob('*.py')` ищет все файлы с расширением `.py` в текущем каталоге и возвращает их в виде списка. `glob` также поддерживает подстановочные знаки в стиле shell для поиска шаблонов:
```python
>>> import glob
>>> for name in glob.glob('*[0-9]*.txt'):
...     print(name)
```

Находит все текстовые файлы (`.txt`), содержащие цифры в имени файла:
```shell
data_01.txt
data_03.txt
data_03_backup.txt
data_02_backup.txt
data_02.txt
data_01_backup.txt
```

`glob` облегчает поиск файлов [рекурсивно](https://realpython.com/python-thinking-recursively/) в подкаталогах:
```python
>>> import glob
>>> for file in glob.iglob('**/*.py', recursive=True):
...     print(file)
```

В этом примере используется `glob.iglob()` для поиска файлов `.py` в текущем каталоге и подкаталогах. Передача `recursive=True` в качестве аргумента в `.iglob()` заставляет его искать файлы `.py` в текущей директории и любых поддиректориях. Разница между `glob.iglob()` и `glob.glob()` заключается в том, что `.iglob()` возвращает итератор, а не список.

Выполнение приведенной выше программы дает следующий результат:
```shell
admin.py
tests.py
sub_dir/file1.py
sub_dir/file2.py
```

`pathlib` содержит аналогичные методы для гибкого создания списков файлов. В примере ниже показано, как можно использовать `.Path.glob()` для получения списка типов файлов, начинающихся с буквы `p`:
```python
>>> from pathlib import Path
>>> p = Path('.')
>>> for name in p.glob('*.p*'):
...     print(name)

admin.py
scraper.py
docs.pdf
```

Вызов `p.glob('*.p*')` возвращает объект-генератор, указывающий на все файлы в текущем каталоге, которые начинаются с буквы `p` в расширении файла.

`Path.glob()` аналогичен рассмотренному выше `os.glob()`. Как видите, `pathlib` сочетает в себе многие из лучших возможностей модулей `os`, `os.path` и `glob` в одном единственном модуле, что делает его использование весьма удобным.

В заключение приведем таблицу функций, которые мы рассмотрели в этом разделе:

Функция | Описание
-- | --
`startswith()` | Проверяет, начинается ли строка с указанного шаблона, и возвращает `True` или `False`.
`endswith()` | Проверяет, заканчивается ли строка указанным шаблоном, и возвращает `True` или `False`.
`fnmatch.fnmatch(filename, pattern)` | Проверяет, соответствует ли имя файла шаблону, и возвращает `True` или `False`.
`glob.glob()` | Возвращает список имен файлов, соответствующих шаблону
`pathlib.Path.glob()` | Находит шаблоны в именах путей и возвращает объект генератора

## Обход каталогов и обработка файлов

Распространенной задачей программирования является прохождение по дереву каталогов и обработка файлов в этом дереве. Давайте рассмотрим, как для этого можно использовать встроенную функцию Python `os.walk()`. Функция `os.walk()` используется для генерации имен файлов в дереве каталогов путем обхода дерева сверху вниз или снизу вверх. В данном разделе мы будем работать со следующим деревом каталогов:
```
.
|
├── folder_1/
|   ├── file1.py
|   ├── file2.py
|   └── file3.py
|
├── folder_2/
|   ├── file4.py
|   ├── file5.py
|   └── file6.py
|
├── test1.txt
└── test2.txt
```

Ниже приведен пример, показывающий, как перечислить все файлы и каталоги в дереве каталогов с помощью `os.walk()`.

По умолчанию `os.walk()` обходит каталоги сверху вниз:
```python
# Walking a directory tree and printing the names of the directories and files
for dirpath, dirnames, files in os.walk('.'):
    print(f'Found directory: {dirpath}')
    for file_name in files:
        print(file_name)
```

На каждой итерации цикла `os.walk()` возвращает три значения:

1.  Имя текущей папки
2.  Список папок в текущей папке
3.  Список файлов в текущей папке

На каждой итерации выводит имена найденных подкаталогов и файлов:
```shell
Found directory: .
test1.txt
test2.txt
Found directory: ./folder_1
file1.py
file3.py
file2.py
Found directory: ./folder_2
file4.py
file5.py
file6.py
```

Чтобы обойти дерево каталогов снизу вверх, передайте ключевое слово `topdown=False` в аргументе `os.walk()`:
```python
or dirpath, dirnames, files in os.walk('.', topdown=False):
    print(f'Found directory: {dirpath}')
    for file_name in files:
        print(file_name)
```

Передача аргумента `topdown=False` заставит `os.walk()` выводить сначала файлы, найденные в _подкаталогах_:
```shell
Found directory: ./folder_1
file1.py
file3.py
file2.py
Found directory: ./folder_2
file4.py
file5.py
file6.py
Found directory: .
test1.txt
test2.txt
```

Как вы видите, программа начала с перечисления содержимого подкаталогов, а затем перечислила содержимое корневого каталога. Это очень полезно в ситуациях, когда требуется рекурсивное удаление файлов и каталогов. Как это сделать, вы узнаете в следующих разделах.По умолчанию `os.walk` не переходит по символическим ссылкам, которые ссылаются на каталоги. Это поведение можно отменить, вызвав его с аргументом `followlinks=True`.

## Создание временных файлов и каталогов

Python предоставляет удобный модуль для создания временных файлов и каталогов под названием `tempfile`.

`tempfile` можно использовать для открытия и временного хранения данных в файле или каталоге во время работы вашей программы. Когда ваша программа завершает работу с временными файлами, `tempfile` удаляет их.

Вот как создать временный файл:
```python
from tempfile import TemporaryFile

# Create a temporary file and write some data to it
fp = TemporaryFile('w+t')
fp.write('Hello universe!')

# Go back to the beginning and read data from file
fp.seek(0)
data = fp.read()

# Close the file, after which it will be removed
fp.close()
```

Первым шагом будет импорт `TemporaryFile` из модуля `tempfile`. Затем создайте объект типа файла с помощью метода `TemporaryFile()`, вызвав его и передав режим, в котором вы хотите открыть файл. В результате будет создан и открыт файл, который можно использовать в качестве временного хранилища.

В приведенном выше примере режим - `'w+t'`, что заставляет `tempfile` создать временный текстовый файл в режиме записи. Нет необходимости давать временному файлу имя, так как он будет уничтожен после завершения работы скрипта.

После записи в файл, вы можете читать из него и закрыть его, когда закончите обработку. После закрытия файла он будет удален из файловой системы. Если вам нужно дать имя временным файлам, созданным с помощью `tempfile`, используйте `tempfile.NamedTemporaryFile()`.

Временные файлы и каталоги, созданные с помощью `tempfile`, хранятся в специальном системном каталоге для хранения временных файлов. Python просматривает стандартный список каталогов, чтобы найти тот, в котором пользователь может создавать файлы.

Для Windows такими каталогами являются `C:\TEMP`, `C:\TMP`, `\TEMP` и `\TMP`, в таком порядке. На всех других платформах каталогами являются `/tmp`, `/var/tmp`, и `/usr/tmp`, в таком порядке. В крайнем случае, `tempfile` сохранит временные файлы и каталоги в текущем каталоге.

`.TemporaryFile()` также является менеджером контекста, поэтому его можно использовать в сочетании с оператором `with`. Использование менеджера контекста позволяет автоматически закрыть и удалить файл после его чтения:
```python
with TemporaryFile('w+t') as fp:
    fp.write('Hello universe!')
    fp.seek(0)
    fp.read()
# File is now closed and removed
```

Создается временный файл и из него считываются данные. Как только содержимое файла будет прочитано, временный файл закрывается и удаляется из файловой системы.

`tempfile` можно также использовать для создания временных каталогов. Давайте рассмотрим, как это можно сделать с помощью функции `tempfile.TemporaryDirectory()`:
```python
>>> import tempfile
>>> with tempfile.TemporaryDirectory() as tmpdir:
...     print('Created temporary directory ', tmpdir)
...     os.path.exists(tmpdir)
...
Created temporary directory  /tmp/tmpoxbkrm6c
True

>>> # Directory contents have been removed
...
>>> tmpdir
'/tmp/tmpoxbkrm6c'
>>> os.path.exists(tmpdir)
False
```

Вызов `tempfile.TemporaryDirectory()` создает временный каталог в файловой системе и возвращает объект, представляющий этот каталог. В приведенном выше примере каталог создается с помощью контекстного менеджера, а имя каталога хранится в `tmpdir`. В третьей строке выводится имя временного каталога, а `os.path.exists(tmpdir)` подтверждает, действительно ли каталог был создан в файловой системе.

После выхода менеджера контекста из контекста временный каталог удаляется, а вызов `os.path.exists(tmpdir)` возвращает `False`, что означает, что каталог был успешно удален.


## Удаление файлов и каталогов

Вы можете удалять отдельные файлы, каталоги и целые деревья каталогов, используя методы, представленные в модулях `os`, `shutil` и `pathlib`. В следующих разделах описано, как удалять файлы и каталоги, которые вам больше не нужны.

### Удаление файлов в Python

Чтобы удалить один файл, используйте `pathlib.Path.unlink()`, `os.remove()` или `os.unlink()`.

`os.remove()` и `os.unlink()` семантически идентичны. Чтобы удалить файл с помощью `os.remove()`, сделайте следующее:
```python
import os

data_file = 'C:\\Users\\vuyisile\\Desktop\\Test\\data.txt'
os.remove(data_file)
```

Удаление файла с помощью `os.unlink()` аналогично тому, как это делается с помощью `os.remove()`:
```python
import os

data_file = 'C:\\Users\\vuyisile\\Desktop\\Test\\data.txt'
os.unlink(data_file)
```

Вызов `.unlink()` или `.remove()` для файла удаляет его из файловой системы. Эти две функции выдадут ошибку `OSError`, если переданный им путь указывает на каталог, а не на файл. Чтобы избежать этого, вы можете либо проверить, что то, что вы пытаетесь удалить, действительно является файлом, и удалить его только в этом случае, либо использовать обработку исключений для обработки `OSError`:
```python
import os

data_file = 'home/data.txt'

# If the file exists, delete it
if os.path.isfile(data_file):
    os.remove(data_file)
else:
    print(f'Error: {data_file} not a valid filename')
```

`os.path.isfile()` проверяет, действительно ли `data_file` является файлом. Если да, то он удаляется вызовом `os.remove()`. Если `data_file` указывает на папку, в консоль выводится сообщение об ошибке.

В следующем примере показано, как использовать обработку исключений для обработки ошибок при удалении файлов:
```python
import os

data_file = 'home/data.txt'

# Use exception handling
try:
    os.remove(data_file)
except OSError as e:
    print(f'Error: {data_file} : {e.strerror}')
```

Приведенный выше код сначала пытается удалить файл, прежде чем проверить его тип. Если `data_file` не является файлом, то возникающая `OSError` обрабатывается в выражении `except`, и сообщение об ошибке выводится в консоль. Выведенное сообщение об ошибке форматируется с помощью [Python f-strings](https://realpython.com/python-f-strings/).

Наконец, вы также можете использовать `pathlib.Path.unlink()` для удаления файлов:
```python
from pathlib import Path

data_file = Path('home/data.txt')

try:
    data_file.unlink()
except IsADirectoryError as e:
    print(f'Error: {data_file} : {e.strerror}')
```

Это создает объект `Path` под названием `data_file`, который указывает на файл. Вызов `.remove()` для `data_file` удалит `home/data.txt`. Если `data_file` указывает на каталог, будет возникать ошибка `IsADirectoryError`. Стоит отметить, что приведенная выше Python программа имеет те же разрешения, что и выполняющий ее пользователь. Если у пользователя нет прав на удаление файла, будет выдана ошибка `PermissionError`.

### Удаление каталогов

Стандартная библиотека предлагает следующие функции для удаления каталогов:

-   `os.rmdir()`
-   `pathlib.Path.rmdir()`
-   `shutil.rmtree()`

Для удаления одного каталога или папки используйте `os.rmdir()` или `pathlib.rmdir()`. Эти две функции работают только в том случае, если каталог, который вы пытаетесь удалить, пуст. Если каталог не пуст, будет выдана ошибка `OSError`. Вот как удалить папку:
```python
import os

trash_dir = 'my_documents/bad_dir'

try:
    os.rmdir(trash_dir)
except OSError as e:
    print(f'Error: {trash_dir} : {e.strerror}')
```

Здесь каталог `trash_dir` удаляется путем передачи его пути в `os.rmdir()`. Если каталог не пуст, на экран выводится сообщение об ошибке:
```python
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
OSError: [Errno 39] Directory not empty: 'my_documents/bad_dir'
```

В качестве альтернативы вы можете использовать `pathlib` для удаления каталогов:
```python
from pathlib import Path

trash_dir = Path('my_documents/bad_dir')

try:
    trash_dir.rmdir()
except OSError as e:
    print(f'Error: {trash_dir} : {e.strerror}')
```

Здесь вы создаете объект `Path`, который указывает на каталог, подлежащий удалению. Вызов `.rmdir()` для объекта `Path` удалит его, если он пуст.


### Удаление целых деревьев каталогов

Для удаления непустых каталогов и целых деревьев каталогов Python предлагает `shutil.rmtree()`:
```python
import shutil

trash_dir = 'my_documents/bad_dir'

try:
    shutil.rmtree(trash_dir)
except OSError as e:
    print(f'Error: {trash_dir} : {e.strerror}')
```

Все, что находится в `trash_dir`, удаляется при вызове `shutil.rmtree()`. Бывают случаи, когда требуется рекурсивно удалить пустые папки. Вы можете сделать это, используя один из методов, рассмотренных выше, в сочетании с `os.walk()`:
```python
import os

for dirpath, dirnames, files in os.walk('.', topdown=False):
    try:
        os.rmdir(dirpath)
    except OSError as ex:
        pass
```

Эта программа проходит по дереву каталогов и пытается удалить каждый найденный каталог. Если каталог не пуст, выдается ошибка `OSError` и каталог пропускается. В таблице ниже перечислены функции, рассматриваемые в этом разделе:

Функция | Описание
-- | --
`os.remove()` | Удаляет файл, но не удаляет каталоги
`os.unlink()` | Идентичен `os.remove()` и удаляет один файл
`pathlib.Path.unlink()` | Удаляет файл и не может удалять каталоги
`os.rmdir()` | Удаляет пустой каталог
`pathlib.Path.rmdir()` | Удаляет пустой каталог
`shutil.rmtree()` | Удаляет все древо каталогов и может применяться для удаления непустых каталогов

## Копирование, перемещение и переименование файлов и каталогов

Python содержит модуль `shutil`. Сокращение `shutil` означает shell utilities (утилиты оболочки). Он предоставляет ряд высокоуровневых операций над файлами для копирования, архивирования и удаления файлов и каталогов. В этом разделе вы узнаете, как перемещать и копировать файлы и каталоги.

### Копирование файлов в Python

`shutil` предлагает несколько функций для копирования файлов. Наиболее часто используемыми функциями являются `shutil.copy()` и `shutil.copy2()`. Чтобы скопировать файл из одного места в другое с помощью `shutil.copy()`, сделайте следующее:
```python
import shutil

src = 'path/to/file.txt'
dst = 'path/to/dest_dir'
shutil.copy(src, dst)
```

`shutil.copy()` сопоставима с командой `cp` в системах на базе UNIX. `shutil.copy(src, dst)` копирует файл `src` в место, указанное в `dst`. Если `dst` - файл, содержимое этого файла будет заменено содержимым `src`. Если `dst` - это каталог, то `src` будет скопирован в этот каталог. Функция `shutil.copy()` копирует только содержимое файла и его разрешения. Другие метаданные, такие как время создания и модификации файла, не сохраняются.

Чтобы сохранить все метаданные файла при копировании, используйте `shutil.copy2()`:
```python
import shutil

src = 'path/to/file.txt'
dst = 'path/to/dest_dir'
shutil.copy2(src, dst)
```

Использование `.copy2()` сохраняет подробную информацию о файле, такую как время последнего доступа, биты разрешения, время последней модификации и флаги.

### Копирование каталогов

В то время как `shutil.copy()` копирует только один файл, `shutil.copytree()` копирует весь каталог и все, что в нем содержится. Функция `shutil.copytree(src, dest)` принимает два аргумента: исходный каталог и каталог назначения, в который будут скопированы файлы и папки.

Вот пример того, как скопировать содержимое одной папки в другое место:
```python
>>> import shutil
>>> shutil.copytree('data_1', 'data1_backup')
'data1_backup'
```

В этом примере `.copytree()` копирует содержимое `data_1` в новое место `data1_backup` и возвращает каталог назначения. Каталог назначения не должен быть уже существующим. Он будет создан, как и отсутствующие родительские каталоги. `shutil.copytree()` является хорошим способом резервного копирования файлов.


### Перемещение файлов и каталогов

Чтобы переместить файл или каталог в другое место, используйте `shutil.move(src, dst)`.

src` - это файл или каталог, который нужно переместить, а `dst` - место назначения:
```python
>>> import shutil
>>> shutil.move('dir_1/', 'backup/')
'backup'
```

`shutil.move('dir_1/', 'backup/')` перемещает `dir_1/` в `backup/`, если `backup/` существует. Если `backup/` не существует, `dir_1/` будет переименован в `backup`.

### Переименование файлов и каталогов

Python содержит `os.rename(src, dst)` для переименования файлов и каталогов:
```python
>>> os.rename('first.zip', 'first_01.zip')
```

Строка выше переименует `first.zip` в `first_01.zip`. Если путь назначения указывает на каталог, то возникнет ошибка `OSError`.

Другим способом переименования файлов или каталогов является использование `rename()` из модуля `pathlib`:
```python
>>> from pathlib import Path
>>> data_file = Path('data_01.txt')
>>> data_file.rename('data.txt')
```

Чтобы переименовать файлы с помощью `pathlib`, сначала создайте объект `pathlib.Path()`, содержащий путь к файлу, который вы хотите заменить. Следующим шагом будет вызов `rename()` для объекта path и передача нового имени файла или каталога, который вы переименовываете.

## Архивирование

Архивы - это удобный способ упаковать несколько файлов в один. Два наиболее распространенных типа архивов - ZIP и TAR. Программы на Python, которые вы пишете, могут создавать, читать и извлекать данные из архивов. В этом разделе вы узнаете, как читать и записывать в оба формата архивов.

### Чтение ZIP-файлов

Модуль [`zipfile`](https://realpython.com/python-zipfile/) - это модуль низкого уровня, который является частью стандартной библиотеки Python. `zipfile` содержит функции, которые облегчают открытие и извлечение ZIP-файлов. Чтобы прочитать содержимое ZIP-файла, первым делом нужно создать объект `ZipFile`. Объекты `ZipFile` похожи на объекты файлов, созданные с помощью `open()`. `ZipFile` также является менеджером контекста и поэтому поддерживает оператор `with`:
```python
import zipfile

with zipfile.ZipFile('data.zip', 'r') as zipobj:
```

Здесь вы создаете объект `ZipFile`, в качестве параметра передавая имя ZIP-файла для открытия в режиме чтения. После открытия ZIP-файла информация об архиве может быть доступна через функции, предоставляемые модулем `zipfile`. Архив `data.zip` в приведенном выше примере был создан из каталога `data`, содержащего в общей сложности 5 файлов и 1 подкаталог:
```
.
|
├── sub_dir/
|   ├── bar.py
|   └── foo.py
|
├── file1.py
├── file2.py
└── file3.py
```

Чтобы получить список файлов в архиве, вызовите `namelist()` на объекте `ZipFile`:
```python
import zipfile

with zipfile.ZipFile('data.zip', 'r') as zipobj:
    zipobj.namelist()
```

В результате получится список:
```shell
['file1.py', 'file2.py', 'file3.py', 'sub_dir/', 'sub_dir/bar.py', 'sub_dir/foo.py']
```

`.namelist()` возвращает список имен файлов и каталогов в архиве. Чтобы получить информацию о файлах в архиве, используйте `.getinfo()`:
```python
import zipfile

with zipfile.ZipFile('data.zip', 'r') as zipobj:
    bar_info = zipobj.getinfo('sub_dir/bar.py')
    bar_info.file_size
```

Вот результат:
```shell
15277
```

`.getinfo()` возвращает объект `ZipInfo`, который хранит информацию об одном элементе архива. Чтобы получить информацию о файле в архиве, вы передаете его путь в качестве аргумента в `.getinfo()`. Используя `getinfo()`, вы можете получить такую информацию об элементах архива, как дата последнего изменения файлов, их сжатые размеры и полные имена файлов. Обращение к `.file_size` позволяет получить исходный размер файла в байтах.

Следующий пример показывает, как получить более подробную информацию об архивированных файлах в Python REPL. Предположим, что модуль `zipfile` был импортирован, а `bar_info` - это тот же объект, который вы создали в предыдущих примерах:
```python
>>> bar_info.date_time
(2018, 10, 7, 23, 30, 10)
>>> bar_info.compress_size
2856
>>> bar_info.filename
'sub_dir/bar.py'
```

`bar_info` содержит подробную информацию о файле `bar.py`, такую как его размер после сжатия и полный путь к нему.

В первой строке показано, как получить дату последнего изменения файла. Следующая строка показывает, как получить размер файла после сжатия. Последняя строка показывает полный путь к файлу `bar.py` в архиве.

`ZipFile` поддерживает протокол контекстного менеджера, поэтому вы можете использовать его с оператором `with`. Это автоматически закрывает объект `ZipFile` после того, как вы закончили работу с ним. Попытка открыть или извлечь файлы из закрытого объекта `ZipFile` приведет к ошибке.


### Извлечение ZIP-архивов

Модуль `zipfile` позволяет извлекать один или несколько файлов из ZIP-архивов с помощью методов `.extract()` и `.extractall()`.

По умолчанию эти методы извлекают файлы в текущий каталог. Оба они принимают необязательный параметр `path`, который позволяет указать другой каталог для извлечения файлов. Если каталог не существует, он создается автоматически. Чтобы извлечь файлы из архива, сделайте следующее:
```python
>>> import zipfile
>>> import os

>>> os.listdir('.')
['data.zip']

>>> data_zip = zipfile.ZipFile('data.zip', 'r')

>>> # Extract a single file to current directory
>>> data_zip.extract('file1.py')
'/home/terra/test/dir1/zip_extract/file1.py'

>>> os.listdir('.')
['file1.py', 'data.zip']

>>> # Extract all files into a different directory
>>> data_zip.extractall(path='extract_dir/')

>>> os.listdir('.')
['file1.py', 'extract_dir', 'data.zip']

>>> os.listdir('extract_dir')
['file1.py', 'file3.py', 'file2.py', 'sub_dir']

>>> data_zip.close()
```

Третья строка кода - это вызов `os.listdir()`, который показывает, что в текущем каталоге есть только один файл, `data.zip`.

Далее вы открываете `data.zip` в режиме чтения и вызываете `.extract()` для извлечения из него `file1.py`. `.extract()` возвращает полный путь к извлеченному файлу. Поскольку не было указано никакого пути, `.extract()` извлекает `file1.py` в текущий каталог.

Следующая строка выводит список каталогов, который показывает, что текущий каталог теперь включает извлеченный файл в дополнение к оригинальному архиву. Следующая строка показывает, как извлечь весь архив в каталог `zip_extract`. `.extractall()` создает `extract_dir` и извлекает в него содержимое `data.zip`. Последняя строка закрывает ZIP-архив.

### Извлечение данных из архивов, защищенных паролем

`zipfile` поддерживает извлечение ZIP-архивов, защищенных паролем. Чтобы извлечь защищенные паролем ZIP-файлы, передайте пароль в качестве аргумента в метод `.extract()` или `.extractall()`:
```python
>>> import zipfile

>>> with zipfile.ZipFile('secret.zip', 'r') as pwd_zip:
...     # Extract from a password protected archive
...     pwd_zip.extractall(path='extract_dir', pwd='Quish3@o')
```

Это открывает архив `secret.zip` в режиме чтения. Пароль передается в `.extractall()`, и содержимое архива извлекается в `extract_dir`. Архив автоматически закрывается после извлечения благодаря оператору `with`.

### Создание новых ZIP-архивов

Чтобы создать новый ZIP-архив, откройте объект `ZipFile` в режиме записи (`w`) и добавьте файлы, которые вы хотите архивировать:
```python
>>> import zipfile

>>> file_list = ['file1.py', 'sub_dir/', 'sub_dir/bar.py', 'sub_dir/foo.py']
>>> with zipfile.ZipFile('new.zip', 'w') as new_zip:
...     for name in file_list:
...         new_zip.write(name)
```

В примере `new_zip` открывается в режиме записи, и каждый файл из `file_list` добавляется в архив. Когда работа блока `with` завершится, `new_zip` будет закрыт. Открытие ZIP-файла в режиме записи стирает содержимое архива и создает новый архив.

Чтобы добавить файлы в существующий архив, откройте объект `ZipFile` в режиме добавления, а затем добавьте файлы:
```python
>>> # Open a ZipFile object in append mode
>>> with zipfile.ZipFile('new.zip', 'a') as new_zip:
...     new_zip.write('data.txt')
...     new_zip.write('latin.txt')
```

Здесь вы открываете архив `new.zip`, созданный в предыдущем примере, в режиме добавления. Открытие объекта `ZipFile` в режиме добавления позволяет добавлять новые файлы в ZIP-файл, не удаляя его текущее содержимое. После добавления файлов в ZIP-файл оператор `with` выходит из контекста и закрывает ZIP-файл.

### Открытие TAR-архивов

Файлы TAR - это несжатые файловые архивы, подобные ZIP. Они могут быть сжаты с помощью методов сжатия gzip, bzip2 и lzma. Класс `TarFile` позволяет читать и записывать TAR-архивы.

Для чтения из архива выполните следующее:
```python
import tarfile

with tarfile.open('example.tar', 'r') as tar_file:
    print(tar_file.getnames())
```

Объекты `tarfile` открываются как большинство файлоподобных объектов. У них есть функция `open()`, которая принимает режим, определяющий способ открытия файла.

Используйте режимы `'r'`, `'w'` или `'a'`, чтобы открыть несжатый TAR-файл для чтения, записи и добавления, соответственно. Чтобы открыть сжатые TAR-файлы, передайте в `tarfile.open()` аргумент mode в виде `filemode[:compression]`. В таблице ниже перечислены возможные режимы, в которых могут быть открыты файлы TAR:

Режим | Действие
-- | --
`r` | Открывает архив для чтения с прозрачным сжатием
`r:gz` | Открывает архив для чтения со сжатием gzip
`r:bz2` | Открывает архив для чтения со сжатием bzip2
`r:xz` | Открывает архив для чтения со сжатием lzma
`w` | Открывает архив для записи без сжатия
`w:gz` | Открывает архив для записи со сжатием gzip
`w:xz` | Открывает архив для записи в сжатом виде lzma
`a` | Открывает архив для добавления без сжатия

По умолчанию `.open()` работает в режиме `'r'`. Чтобы прочитать несжатый TAR-файл и получить имена файлов в нем, используйте `.getnames()`:
```python
>>> import tarfile

>>> tar = tarfile.open('example.tar', mode='r')
>>> tar.getnames()
['CONTRIBUTING.rst', 'README.md', 'app.py']
```

Это возвращает список с именами содержимого архива.

>**Примечание:** Для того чтобы показать, как использовать различные методы объекта `tarfile`, файл TAR в примерах открывается и закрывается вручную в интерактивной сессии REPL.
>
>Взаимодействие с TAR-файлом таким образом позволяет вам видеть результат выполнения каждой команды. Обычно вы должны использовать контекстный менеджер для открытия файлоподобных объектов.

Доступ к метаданным каждой записи в архиве можно получить с помощью специальных атрибутов:
```python
>>> for entry in tar.getmembers():
...     print(entry.name)
...     print(' Modified:', time.ctime(entry.mtime))
...     print(' Size    :', entry.size, 'bytes')
...     print()
CONTRIBUTING.rst
 Modified: Sat Nov  1 09:09:51 2018
 Size    : 402 bytes

README.md
 Modified: Sat Nov  3 07:29:40 2018
 Size    : 5426 bytes

app.py
 Modified: Sat Nov  3 07:29:13 2018
 Size    : 6218 bytes
```

В этом примере вы перебираете список файлов, возвращенных функцией `.getmembers()`, и выводите атрибуты каждого файла. Объекты, возвращаемые `.getmembers()`, имеют атрибуты, к которым можно обращаться программно, такие как имя, размер и время последнего изменения каждого из файлов в архиве. После чтения или записи в архив он должен быть закрыт, чтобы освободить системные ресурсы.

### Извлечение файлов из архива TAR

В этом разделе вы узнаете, как извлекать файлы из архивов TAR, используя следующие методы:

-   `.extract()`
-   `.extractfile()`
-   `.extractall()`

Чтобы извлечь один файл из архива TAR, используйте `extract()`, передав имя файла:
```python
>>> tar.extract('README.md')
>>> os.listdir('.')
['README.md', 'example.tar']
```

Файл `README.md` извлекается из архива в файловую систему. Вызов `os.listdir()` подтверждает, что файл `README.md` был успешно извлечен в текущий каталог. Чтобы распаковать или извлечь все из архива, используйте `.extractall()`:
```python
>>> tar.extractall(path="extracted/")
```

`.extractall()` имеет необязательный аргумент `path` для указания места, куда должны быть помещены извлеченные файлы. В данном случае архив распаковывается в каталог `extracted`. Следующие команды показывают, что архив был успешно извлечен:
```shell
$ ls
example.tar  extracted  README.md

$ tree
.
├── example.tar
├── extracted
|   ├── app.py
|   ├── CONTRIBUTING.rst
|   └── README.md
└── README.md

1 directory, 5 files

$ ls extracted/
app.py  CONTRIBUTING.rst  README.md
```

Чтобы извлечь файловый объект для чтения или записи, используйте `.extractfile()`, который принимает в качестве аргумента имя файла или объект `TarInfo` для извлечения. `.extractfile()` возвращает файлоподобный объект, который можно читать и использовать:
```python
>>> f = tar.extractfile('app.py')
>>> f.read()
>>> tar.close()
```

Открытые архивы всегда следует закрывать после того, как они были прочитаны или записаны. Чтобы закрыть архив, вызовите `.close()` на дескрипторе файла архива или используйте оператор `with` при создании объектов `tarfile`, чтобы автоматически закрыть архив, когда вы закончите. Это освобождает системные ресурсы и записывает все изменения, внесенные в архив, в файловую систему.

### Создание новых TAR-архивов

Вот как это делается:
```python
>>> import tarfile

>>> file_list = ['app.py', 'config.py', 'CONTRIBUTORS.md', 'tests.py']
>>> with tarfile.open('packages.tar', mode='w') as tar:
...     for file in file_list:
...         tar.add(file)

>>> # Read the contents of the newly created archive
>>> with tarfile.open('package.tar', mode='r') as t:
...     for member in t.getmembers():
...         print(member.name)
app.py
config.py
CONTRIBUTORS.md
tests.py
```

Сначала вы создаете список файлов, которые нужно добавить в архив, чтобы не добавлять каждый файл вручную.

Следующая строка использует контекстный менеджер `with` для открытия нового архива `packages.tar` в режиме записи. Открытие архива в режиме записи (`'w'`) позволяет вам записывать новые файлы в архив. Все существующие файлы в архиве удаляются, и создается новый архив.

После создания и заполнения архива контекстный менеджер `with` автоматически закрывает его и сохраняет в файловой системе. Последние три строки открывают только что созданный архив и выводят имена содержащихся в нем файлов.

Чтобы добавить новые файлы в существующий архив, откройте архив в режиме добавления (`'a'`):
```python
>>> with tarfile.open('package.tar', mode='a') as tar:
...     tar.add('foo.bar')

>>> with tarfile.open('package.tar', mode='r') as tar:
...     for member in tar.getmembers():
...         print(member.name)
app.py
config.py
CONTRIBUTORS.md
tests.py
foo.bar
```

Открытие архива в режиме добавления позволяет добавлять в него новые файлы, не удаляя уже имеющиеся.

### Работа со сжатыми архивами

`tarfile` также может читать и записывать TAR-архивы, сжатые с помощью gzip, bzip2 и lzma. Чтобы прочитать или записать сжатый архив, используйте `tarfile.open()`, передавая соответствующий режим для типа сжатия.

Например, для чтения или записи данных в архив TAR, сжатый с помощью gzip, используйте режимы `'r:gz'` или `'w:gz'` соответственно:
```python
>>> files = ['app.py', 'config.py', 'tests.py']
>>> with tarfile.open('packages.tar.gz', mode='w:gz') as tar:
...     tar.add('app.py')
...     tar.add('config.py')
...     tar.add('tests.py')

>>> with tarfile.open('packages.tar.gz', mode='r:gz') as t:
...     for member in t.getmembers():
...         print(member.name)
app.py
config.py
tests.py
```

Режим `'w:gz'` открывает архив для записи в сжатом формате gzip, а `'r:gz'` открывает архив для чтения в сжатом формате gzip. Открытие сжатых архивов в режиме append невозможно. Чтобы добавить файлы в сжатый архив, необходимо создать новый архив.

## Более простой способ создания архивов

Стандартная библиотека Python также поддерживает создание архивов TAR и ZIP с помощью высокоуровневых методов модуля `shutil`. Утилиты архивирования в `shutil` позволяют создавать, читать и извлекать архивы ZIP и TAR. Эти утилиты основаны на модулях нижнего уровня `tarfile` и `zipfile`.

**Работа с архивами с помощью `shutil.make_archive()`**

Утилита `shutil.make_archive()` принимает как минимум два аргумента: имя архива и формат архива.

По умолчанию, он сжимает все файлы в текущем каталоге в формат архива, указанный в аргументе `format`. Вы можете передать необязательный аргумент `root_dir`, чтобы сжать файлы в другом каталоге. `.make_archive()` поддерживает форматы архивов `zip`, `tar`, `bztar` и `gztar`.

Вот как создать архив TAR с помощью `shutil`:
```python
import shutil

# shutil.make_archive(base_name, format, root_dir)
shutil.make_archive('data/backup', 'tar', 'data/')
```

Это копирует все содержимое `data/` и создает в файловой системе архив с именем `backup.tar` и возвращает его имя. Чтобы извлечь архив, вызовите `.unpack_archive()`:
```python
shutil.unpack_archive('backup.tar', 'extract_dir/')
```

Вызов `.unpack_archive()` и передача имени архива и каталога назначения извлекает содержимое `backup.tar` в `extract_dir/`. ZIP-архивы могут быть созданы и извлечены таким же образом.

## Чтение нескольких файлов

Python поддерживает чтение данных из нескольких входных потоков или из списка файлов с помощью модуля `fileinput`. Этот модуль позволяет быстро и легко перебирать содержимое одного или нескольких текстовых файлов. Вот типичный способ использования `fileinput`:
```python
import fileinput
for line in fileinput.input()
    process(line)
```

По умолчанию `fileinput` получает входные данные из [аргументов командной строки](https://realpython.com/python-command-line-arguments/), передаваемых в `sys.argv`.

**Использование `fileinput` для перебора нескольких файлов**.

Давайте используем `fileinput` для создания простой версии обычной UNIX-утилиты `cat`. Утилита `cat` последовательно читает файлы, записывает их на стандартный вывод. Если в аргументах командной строки указано более одного файла, `cat` объединит их и выведет результат в терминал:
```python
# File: fileinput-example.py
import fileinput
import sys

files = fileinput.input()
for line in files:
    if fileinput.isfirstline():
        print(f'\n--- Reading {fileinput.filename()} ---')
    print(' -> ' + line, end='')
print()
```

Запуск этой программы на двух текстовых файлах в моем текущем каталоге дает следующий результат:
```python
$ python3 fileinput-example.py bacon.txt cupcake.txt
--- Reading bacon.txt ---
 -> Spicy jalapeno bacon ipsum dolor amet in in aute est qui enim aliquip,
 -> irure cillum drumstick elit.
 -> Doner jowl shank ea exercitation landjaeger incididunt ut porchetta.
 -> Tenderloin bacon aliquip cupidatat chicken chuck quis anim et swine.
 -> Tri-tip doner kevin cillum ham veniam cow hamburger.
 -> Turkey pork loin cupidatat filet mignon capicola brisket cupim ad in.
 -> Ball tip dolor do magna laboris nisi pancetta nostrud doner.

--- Reading cupcake.txt ---
 -> Cupcake ipsum dolor sit amet candy I love cheesecake fruitcake.
 -> Topping muffin cotton candy.
 -> Gummies macaroon jujubes jelly beans marzipan.
```

`fileinput` позволяет получить дополнительную информацию о каждой строке, например, является ли она первой (`.isfirstline()`), номер строки (`.lineno()`) и имя файла (`.filename()`). Подробнее об этом можно прочитать [здесь](https://docs.python.org/3/library/fileinput.html).

## Заключение

Теперь вы знаете, как использовать Python для выполнения наиболее распространенных операций над файлами и группами файлов. Вы узнали о различных встроенных модулях, используемых для чтения, поиска и работы с ними.

Теперь вы можете использовать Python для:

- Получения содержимого каталогов и свойств файлов
- Создания каталогов и деревьев каталогов
- Поиска шаблонов в именах файлов
- Создания временных файлов и каталогов
- Перемещения, переименования, копирования и удаления файлов и каталогов
- Чтения и извлечения данных из различных типов архивов
- Чтения нескольких файлов одновременно с помощью `fileinput`.