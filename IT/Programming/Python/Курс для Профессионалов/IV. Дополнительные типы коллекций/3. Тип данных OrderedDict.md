[Real Python (eng, 2021)](https://realpython.com/python-ordereddict/)

Иногда вам нужен [словарь](https://realpython.com/python-dicts/) Python, который помнит порядок своих элементов. В прошлом у вас был только один инструмент для решения этой специфической проблемы: Python [`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict). Это подкласс словаря, специально разработанный для запоминания порядка элементов, который определяется порядком вставки ключей.

Это изменилось в Python 3.6. Встроенный класс `dict` теперь также хранит свои элементы упорядоченными. В связи с этим многие в сообществе Python задаются вопросом, полезен ли еще `OrderedDict`. При ближайшем рассмотрении `OrderedDict` выяснится, что этот класс по-прежнему предоставляет ценные возможности.

**В этом пособии вы узнаете, как:**

- Создавать и использовать объекты **`OrderedDict`** в своем коде
- Определять **различия** между `OrderedDict` и `dict`.
- Понять **плюсы** и **минусы** использования `OrderedDict` и `dict`.

Обладая этими знаниями, вы сможете выбрать класс словаря, который лучше всего подходит для ваших нужд, когда вам нужно сохранить порядок элементов.

К концу урока вы увидите пример реализации очереди на основе словаря с использованием `OrderedDict`, что было бы сложнее, если бы вы использовали обычный объект `dict`.

## Выбор между `OrderedDict` и `dict`

В течение многих лет [словари](https://realpython.com/iterate-through-dictionary-python/#a-few-words-on-dictionaries) в Python были неупорядоченными [структурами данных](https://realpython.com/python-data-structures/). Разработчики Python привыкли к этому факту и полагались на [списки](https://realpython.com/python-lists-tuples/) или другие последовательности, когда им нужно было упорядочить данные. Со временем разработчики обнаружили необходимость в новом типе словаря, который бы сохранял порядок в своих элементах.

Еще в 2008 году в [PEP 372](https://www.python.org/dev/peps/pep-0372/) была представлена идея добавить новый класс словаря в [`collections`](https://docs.python.org/3/library/collections.html#module-collections). Его основной целью было запоминание порядка элементов, определяемого порядком вставки ключей. Так возник `OrderedDict`.

Разработчики основной части Python хотели восполнить пробел и предоставить словарь, который мог бы сохранять порядок вставленных ключей. Это, в свою очередь, позволило упростить реализацию специфических алгоритмов, которые полагаются на это свойство.

`OrderedDict` был добавлен в стандартную библиотеку в [Python 3.1] (https://docs.python.org/3/whatsnew/3.1.html). Его API по сути такой же, как и у `dict`. Однако `OrderedDict` выполняет итерации по ключам и значениям в том же порядке, в котором ключи были вставлены. Если новая запись перезаписывает существующую, то порядок элементов остается неизменным. Если запись удаляется и вставляется заново, то она перемещается в конец словаря.

В Python 3.6 появилась [новая реализация `dict`](https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation). Эта новая реализация представляет собой большой выигрыш с точки зрения использования памяти и эффективности итераций. Кроме того, новая реализация предоставляет новую и несколько неожиданную возможность: объекты `dict` теперь сохраняют свои элементы в том же порядке, в котором они были добавлены. Изначально эта возможность считалась деталью реализации, и документация не рекомендовала полагаться на нее.

>**Примечание:** В этом руководстве вы сосредоточитесь на реализации `dict` и `OrderedDict`, которые предоставляет [CPython](https://www.python.org/about/).

По словам [Raymond Hettinger](https://twitter.com/raymondh), основного разработчика Python и соавтора `OrderedDict`, класс был специально разработан для того, чтобы его элементы были упорядочены, в то время как новая реализация `dict` была разработана для компактности и быстрой итерации:

>Сегодняшний стандартный словарь основан на конструкции, которую я предложил несколько лет назад. Основными целями этого проекта были компактность и более быстрая итерация по длинным массивам ключей и значений. Поддержание порядка было скорее артефактом, чем целью проекта. Конструкция может поддерживать порядок, но это не ее специализация.
>
В противоположность этому, я дал `collections.OrderedDict` другой дизайн (позже он был написан на языке C Эриком Сноу). Основной целью было эффективное поддержание порядка даже при серьезных нагрузках, таких как нагрузка от `lru_cache`, который часто изменяет порядок, не затрагивая основной `dict`. Намеренно, `OrderedDict` имеет дизайн, в котором приоритет отдается возможности упорядочивания ценой дополнительных накладных расходов памяти и постоянного фактора ухудшения времени вставки.
>
Моей целью по-прежнему является то, чтобы `коллекции.OrderedDict` имели другой дизайн с другими характеристиками производительности, чем обычные словари. У него есть некоторые специфические методы для упорядоченных объектов, которых нет у обычных dicts (например, `move_to_end()` и `popitem()`, который эффективно вынимает объект с любого конца). `OrderedDict` должен быть хорош в этих операциях, потому что это то, что отличает его от обычных dicts. ([Источник](https://mail.python.org/pipermail/python-dev/2017-December/151266.html))

В [Python 3.7] (https://realpython.com/python37-new-features/) функция упорядочивания элементов объектов `dict` была [объявлена] (https://mail.python.org/pipermail/python-dev/2017-December/151283.html) официальной частью спецификации языка Python. Таким образом, с этого момента разработчики могли полагаться на `dict`, когда им требовался словарь, сохраняющий порядок элементов.

В этот момент возникает вопрос: Нужен ли еще `OrderedDict` после новой реализации `dict`? Ответ зависит от вашего конкретного случая использования, а также от того, насколько явным вы хотите быть в своем коде.

На момент написания статьи некоторые особенности `OrderedDict` все еще делали его ценным и отличным от обычного `dict`:

1.  **Выражение намерения:** Если вы используете `OrderedDict` вместо `dict`, то ваш код дает понять, что порядок элементов в словаре важен. Вы четко сообщаете, что ваш код нуждается или полагается на порядок элементов в используемом словаре.
2.  **Контроль над порядком элементов:** Если вам нужно переставить или изменить порядок элементов в словаре, то вы можете использовать [`.move_to_end()`](https://docs.python.org/3/library/collections.html#collections.OrderedDict.move_to_end), а также расширенный вариант [`.popitem()`](https://docs.python.org/3/library/collections.html#collections.OrderedDict.popitem).
3.  **Если ваш код сравнивает словари на равенство, и порядок элементов важен в этом сравнении, то `OrderedDict` - правильный выбор.

Есть еще как минимум одна причина продолжать использовать `OrderedDict` в вашем коде: **обратная совместимость**. Полагаясь на обычные объекты `dict` для сохранения порядка элементов, вы сломаете свой код в средах, использующих версии Python старше 3.6.

Трудно сказать, скоро ли `dict` полностью заменит `OrderedDict`. В настоящее время `OrderedDict` все еще предлагает интересные и ценные возможности, которые вы, возможно, захотите учесть при выборе инструмента для конкретной работы.

## Начало работы с `OrderedDict` в Python

Python `OrderedDict` - это подкласс `dict`, который сохраняет порядок, в котором **пары ключ-значение**, известные как **элементы**, вставляются в словарь. Когда вы выполняете итерацию над объектом `OrderedDict`, элементы обрабатываются в исходном порядке. Если вы обновляете значение существующего ключа, то порядок остается неизменным. Если вы удалите элемент и вставите его заново, то он будет добавлен в конец словаря.

Подкласс `dict` означает, что он наследует все методы обычного словаря. У `OrderedDict` также есть дополнительные возможности, о которых вы узнаете в этом руководстве. В этом разделе, однако, вы изучите основы создания и использования объектов `OrderedDict` в вашем коде.

### Создание объектов `OrderedDict`

В отличие от `dict`, `OrderedDict` не является встроенным типом, поэтому первым шагом для создания объектов `OrderedDict` является [импорт](https://realpython.com/python-import/) класса из `collections`. Существует несколько способов создания упорядоченных словарей. Большинство из них идентичны тому, как вы создаете обычный объект `dict`. Например, вы можете создать пустой объект `OrderedDict`, инстанцировав класс без аргументов:
```python
from collections import OrderedDict

>>> numbers = OrderedDict()

>>> numbers["one"] = 1
>>> numbers["two"] = 2
>>> numbers["three"] = 3

>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3)])
```

В этом случае вы сначала импортируете `OrderedDict` из `collections`. Затем вы создаете пустой упорядоченный словарь, инстанцируя `OrderedDict` без указания аргументов в конструкторе.

Вы можете добавить пары ключ-значение в словарь, указав ключ в квадратных скобках (`[]`) и присвоив значение этому ключу. Когда вы обращаетесь к `numbers`, вы получаете итерабельную последовательность пар ключ-значение, которая содержит элементы в том же порядке, в котором они были вставлены в словарь.

Вы также можете передать итерабельную последовательность элементов в качестве аргумента конструктору `OrderedDict`:
```python
from collections import OrderedDict

>>> numbers = OrderedDict([("one", 1), ("two", 2), ("three", 3)])
>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3)])

>>> letters = OrderedDict({("a", 1), ("b", 2), ("c", 3)})
>>> letters
OrderedDict([('c', 3), ('a', 1), ('b', 2)])
```

Когда вы используете [последовательность](https://docs.python.org/3/library/stdtypes.html?highlight=sequence#sequence-types-list-tuple-range), такую как `list` или `tuple`, порядок элементов в результирующем упорядоченном словаре соответствует исходному порядку элементов во входной последовательности. Если вы используете `set`, как во втором примере выше, то окончательный порядок элементов неизвестен до создания `OrderedDict`.

Если вы используете стандартный словарь в качестве инициализатора объекта `OrderedDict` и используете Python 3.6 или более поздние версии, то вы получите следующее поведение:
```python
Python 3.9.0 (default, Oct  5 2020, 17:52:02)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from collections import OrderedDict

>>> numbers = OrderedDict({"one": 1, "two": 2, "three": 3})
>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3)])
```

Порядок элементов в объекте `OrderedDict` соответствует порядку в исходном словаре. С другой стороны, если вы используете Python версии ниже 3.6, то порядок элементов неизвестен:
```python
Python 3.5.10 (default, Jan 25 2021, 13:22:52)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from collections import OrderedDict

>>> numbers = OrderedDict({"one": 1, "two": 2, "three": 3})
>>> numbers
OrderedDict([('one', 1), ('three', 3), ('two', 2)])
```

Поскольку словари в Python 3.5 не запоминают порядок своих элементов, вы не знаете порядок в результирующем упорядоченном словаре до тех пор, пока объект не будет создан. С этого момента порядок сохраняется.

Вы можете создать упорядоченный словарь, передав [именованые аргументы](https://realpython.com/defining-your-own-python-function/#keyword-arguments) в конструктор класса:
```python
from collections import OrderedDict

>>> numbers = OrderedDict(one=1, two=2, three=3)
>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3)])
```

Начиная с [Python 3.6](https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep468), функции сохраняют порядок аргументов ключевых слов, переданных при вызове. Таким образом, порядок элементов в приведенном выше `OrderedDict` соответствует порядку, в котором вы передаете ключевые аргументы в конструктор. В более ранних версиях Python этот порядок неизвестен.

Наконец, `OrderedDict` также предоставляет функцию `.fromkeys()`, которая создает новый словарь из итерабельного набора ключей и устанавливает все его значения в единое значение:
```python
from collections import OrderedDict

>>> keys = ["one", "two", "three"]
>>> OrderedDict.fromkeys(keys, 0)
OrderedDict([('one', 0), ('two', 0), ('three', 0)])
```

In this case, you create an ordered dictionary using a list of keys as starting point. The second argument to `.fromkeys()` provides a single value to all the items in the dictionary.

### Управление элементами в `OrderedDict`

Поскольку `OrderedDict` является [изменяемой](https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types) структурой данных, вы можете выполнять **изменяющие операции** над ее экземплярами. Вы можете вставлять новые элементы, обновлять и удалять существующие элементы и так далее. Если вы вставляете новый элемент в существующий упорядоченный словарь, то этот элемент добавляется в конец словаря:
```python
from collections import OrderedDict

>>> numbers = OrderedDict(one=1, two=2, three=3)
>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3)])

>>> numbers["four"] = 4
>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3), ('four', 4)])
```

Новый добавленный элемент, `('four', 4)`, помещается в конец основного словаря, поэтому порядок существующих элементов не изменяется, и словарь сохраняет порядок вставки.

Если вы удалите элемент из существующего упорядоченного словаря и снова вставите тот же элемент, то новый экземпляр элемента будет помещен в конец словаря:
```python
from collections import OrderedDict
>>> numbers = OrderedDict(one=1, two=2, three=3)

>>> del numbers["one"]
>>> numbers
OrderedDict([('two', 2), ('three', 3)])

>>> numbers["one"] = 1
>>> numbers
OrderedDict([('two', 2), ('three', 3), ('one', 1)])
```

Если вы удалите элемент `('one', 1)` и вставите новый экземпляр того же элемента, то новый элемент будет добавлен в конец базового словаря.

Если вы переназначаете или обновляете значение существующей пары ключ-значение в объекте `OrderedDict`, то ключ сохраняет свою позицию, но получает новое значение:
```python
from collections import OrderedDict
>>> numbers = OrderedDict(one=1, two=2, three=3)

>>> numbers["one"] = 1.0
>>> numbers
OrderedDict([('one', 1.0), ('two', 2), ('three', 3)])

>>> numbers.update(two=2.0)
>>> numbers
OrderedDict([('one', 1.0), ('two', 2.0), ('three', 3)])
```

Если вы обновляете значение заданного ключа в упорядоченном словаре, то ключ не перемещается, а присваивается новое значение на месте. Точно так же, если вы используете `.update()` для изменения значения существующей пары ключ-значение, то словарь запоминает позицию ключа и присваивает ему обновленное значение.

### Итерация по `OrderedDict`.

Как и в случае с обычными словарями, вы можете [итерировать](https://realpython.com/iterate-through-dictionary-python/) объект `OrderedDict`, используя несколько инструментов и техник. Вы можете выполнять итерацию непосредственно по ключам или использовать методы словаря, такие как [`.items()`](https://docs.python.org/3/library/stdtypes.html#dict.items), [`.keys()`](https://docs.python.org/3/library/stdtypes.html#dict.keys) и [`.values()`](https://docs.python.org/3/library/stdtypes.html#dict.values):
```python
from collections import OrderedDict
>>> numbers = OrderedDict(one=1, two=2, three=3)

>>> # Итерация непосредственно по ключам
>>> for key in numbers:
...     print(key, "->", numbers[key])
...
one -> 1
two -> 2
three -> 3

>>> # Итерация по элементам с помощью .items()
>>> for key, value in numbers.items():
...     print(key, "->", value)
...
one -> 1
two -> 2
three -> 3

>>> # Итерация по ключам с помощью .keys()
>>> for key in numbers.keys():
...     print(key, "->", numbers[key])
...
one -> 1
two -> 2
three -> 3

>>> # Итерация по значениям с помощью .values()
>>> for value in numbers.values():
...     print(value)
...
1
2
3
```

Первый цикл [`for`](https://realpython.com/python-for-loop/) выполняет итерацию по ключам `numbers` напрямую. Остальные три цикла используют методы словаря для итерации по элементам, ключам и значениям `numbers`.

### Итерация в обратном порядке с помощью `reversed()`.

Еще одна важная особенность `OrderedDict`, появившаяся в [Python 3.5](https://docs.python.org/3/whatsnew/3.5.html#collections), заключается в том, что его элементы, ключи и значения поддерживают обратную итерацию с помощью [`reversed()`](https://docs.python.org/3/library/functions.html#reversed). Эта [возможность](https://docs.python.org/3/whatsnew/3.8.html#other-language-changes) была добавлена к обычным словарям в [Python 3.8](https://realpython.com/python38-new-features/). Поэтому, если ваш код использует ее, то ваша обратная совместимость с обычными словарями будет гораздо более ограниченной.

Вы можете использовать `reversed()` с элементами, ключами и значениями объекта `OrderedDict`:
```python
from collections import OrderedDict
>>> numbers = OrderedDict(one=1, two=2, three=3)

>>> # Прямая итерация по ключам в обратном порядке
>>> for key in reversed(numbers):
...     print(key, "->", numbers[key])
...
three -> 3
two -> 2
one -> 1

>>> # Итерация по элементам в обратном порядке
>>> for key, value in reversed(numbers.items()):
...     print(key, "->", value)
...
three -> 3
two -> 2
one -> 1

>>> # Итерация по ключам в обратном порядке
>>> for key in reversed(numbers.keys()):
...     print(key, "->", numbers[key])
...
three -> 3
two -> 2
one -> 1

>>> # Итерация по значениям в обратном порядке
>>> for value in reversed(numbers.values()):
...     print(value)
...
3
2
1
```

Все циклы в этом примере используют `reversed()` для перебора различных элементов упорядоченного словаря в обратном порядке.

Обычные словари также поддерживают обратную итерацию. Однако, если вы попытаетесь использовать `reversed()` с обычным объектом `dict` в Python версии ниже 3.8, то получите ошибку `TypeError`:
```python
Python 3.7.9 (default, Jan 14 2021, 11:41:20)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> numbers = dict(one=1, two=2, three=3)

>>> for key in reversed(numbers):
...     print(key)
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'dict' object is not reversible
```

Если вам нужно перебирать элементы словаря в обратном порядке, то `OrderedDict` - хороший помощник. Использование обычного словаря значительно снижает вашу обратную совместимость, потому что обратная итерация не была добавлена в обычные словари до Python 3.8.

## Уникальные возможности `OrderedDict` в Python

Начиная с Python 3.6, обычные словари хранят свои элементы в том же порядке, в котором они были вставлены в базовый словарь. Это ограничивает полезность `OrderedDict`, как вы уже видели. Однако `OrderedDict` предоставляет некоторые уникальные возможности, которые вы не найдете в обычном объекте `dict`.

С упорядоченным словарем у вас есть доступ к следующим дополнительным и расширенным методам:

- [`.move_to_end()`](https://docs.python.org/3/library/collections.html#collections.OrderedDict.move_to_end) - новый метод [добавлен в Python 3.2](https://docs.python.org/3/whatsnew/3.2.html#collections), который позволяет вам переместить существующий элемент либо в конец, либо в начало словаря.
    
- [`.popitem()`](https://docs.python.org/3/library/collections.html#collections.OrderedDict.popitem) - это улучшенная вариация своего аналога [`dict.popitem()`](https://docs.python.org/3/library/stdtypes.html#dict.popitem), позволяющая удалять и возвращать элемент либо из конца, либо из начала базового упорядоченного словаря.


`OrderedDict` и `dict` также ведут себя по-разному, когда их проверяют на равенство. В частности, когда вы сравниваете упорядоченные словари, порядок элементов имеет значение. С обычными словарями дело обстоит иначе.

Наконец, экземпляры `OrderedDict` предоставляют атрибут [`.__dict__`](https://docs.python.org/3/library/stdtypes.html#object.__dict__), который вы не можете найти в экземпляре обычного словаря. Этот атрибут позволяет вам добавлять пользовательские записываемые атрибуты к существующему упорядоченному словарю.

### Упорядочивание элементов с помощью `.move_to_end()`.

Одно из наиболее заметных различий между `dict` и `OrderedDict` заключается в том, что последний имеет дополнительный метод `.move_to_end()`. Этот метод позволяет перемещать существующие элементы либо в конец, либо в начало основного словаря, так что это отличный инструмент для изменения порядка в словаре.

Когда вы используете `.move_to_end()`, вы можете указать два аргумента:

1.  **`key`** содержит ключ, идентифицирующий элемент, который вы хотите переместить. Если `key` не существует, то вы получите [`KeyError`](https://realpython.com/python-keyerror/).
    
2.  **`last`** содержит значение [Boolean](https://realpython.com/python-boolean/), которое определяет, в какой конец словаря вы хотите переместить данный элемент. По умолчанию оно равно `True`, что означает, что элемент будет перемещен в конец, или правую часть, словаря. `False` означает, что элемент будет перемещен в переднюю, или левую, часть упорядоченного словаря.
    

Вот пример использования `.move_to_end()` с аргументом `key` и полагаясь на значение по умолчанию `last`:
```python
from collections import OrderedDict
>>> numbers = OrderedDict(one=1, two=2, three=3)
>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3)])

>>> numbers.move_to_end("one")
>>> numbers
OrderedDict([('two', 2), ('three', 3), ('one', 1)])
```

Когда вы вызываете `.move_to_end()` с `key` в качестве аргумента, вы перемещаете текущую пару ключ-значение в конец словаря. Вот почему `('one', 1)` теперь находится на последней позиции. Обратите внимание, что остальные элементы остаются в том же первоначальном порядке.

Если вы передадите `False` в `last`, то переместите элемент в начало:
```python
numbers.move_to_end("one", last=False)
>>> numbers
OrderedDict([('one', 1), ('two', 2), ('three', 3)])
```

В этом случае вы перемещаете `('one', 1)` в начало словаря. Это дает интересную и мощную возможность. Например, с помощью `.move_to_end()` можно [сортировать упорядоченный словарь](https://realpython.com/sort-python-dictionary/) по ключам:
```python
from collections import OrderedDict
>>> letters = OrderedDict(b=2, d=4, a=1, c=3)

>>> for key in sorted(letters):
...     letters.move_to_end(key)
...
>>> letters
OrderedDict([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
```

В этом примере сначала создается упорядоченный словарь `letters`. В цикле `for` выполняется итерация по отсортированным ключам и перемещение каждого элемента в конец словаря. Когда цикл завершается, ваш упорядоченный словарь имеет элементы, отсортированные по ключам.

Сортировка словаря по значениям была бы интересным упражнением, так что попробуйте!

Отсортируйте следующий словарь по значениям:
```python
>>> from collections import OrderedDict
>>> letters = OrderedDict(a=4, b=3, d=1, c=2)
```

В качестве полезной подсказки для реализации решения рассмотрим использование [`lambda` функции](https://realpython.com/python-lambda/).

Вы можете использовать `lambda` функцию для получения значения каждой пары ключ-значение в `letters` и использовать эту функцию в качестве аргумента `key` в `sorted()`:
```python
>>> for key, _ in sorted(letters.items(), key=lambda item: item[1]):
...     letters.move_to_end(key)
...
>>> letters
OrderedDict([('d', 1), ('c', 2), ('b', 3), ('a', 4)])
```

IВ этом коде вы используете `lambda` функцию, которая возвращает значение каждой пары ключ-значение из `letters`. Вызов `sorted()` использует эту `lambda` функцию для извлечения **ключа сравнения** из каждого элемента итерируемой таблицы `letters.items()`. Затем вы используете `.move_to_end()` для сортировки `letters`.

Отлично! Теперь вы знаете, как переупорядочивать упорядоченные словари с помощью `.move_to_end()`. Вы готовы перейти к следующему разделу.

### Удаление элементов с помощью `.popitem()`.

Еще одной интересной особенностью `OrderedDict` является его улучшенная версия `.popitem()`. По умолчанию `.popitem()` удаляет и возвращает элемент в порядке [LIFO](https://en.wikipedia.org/w/index.php?title=LIFO_(computing)&redirect=no) (Last-In/First-Out). Другими словами, он удаляет элементы с правого конца упорядоченного словаря:
```python
>>> from collections import OrderedDict
>>> numbers = OrderedDict(one=1, two=2, three=3)

>>> numbers.popitem()
('three', 3)
>>> numbers.popitem()
('two', 2)
>>> numbers.popitem()
('one', 1)
>>> numbers.popitem()
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    numbers.popitem()
KeyError: 'dictionary is empty'
```

Здесь вы удаляете все элементы из `numbers` с помощью `.popitem()`. Каждый вызов этого метода удаляет один элемент из конца базового словаря. Если вы вызовете `.popitem()` на пустом словаре, то получите `KeyError`. До этого момента `.popitem()` ведет себя так же, как и в обычных словарях.

В `OrderedDict`, однако, `.popitem()` также принимает булевский аргумент `last`, который по умолчанию равен `True`. Если задать `last` в `False`, то `.popitem()` удаляет элементы в порядке [FIFO](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)) (First-In/First-Out), что означает, что он удаляет элементы из начала словаря:
```python
>>> from collections import OrderedDict
>>> numbers = OrderedDict(one=1, two=2, three=3)

>>> numbers.popitem(last=False)
('one', 1)
>>> numbers.popitem(last=False)
('two', 2)
>>> numbers.popitem(last=False)
('three', 3)
>>> numbers.popitem(last=False)
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    numbers.popitem(last=False)
KeyError: 'dictionary is empty'
```

С `last`, установленным в `False`, вы можете использовать `.popitem()` для удаления и возврата элементов из начала упорядоченного словаря. В этом примере последний вызов `.popitem()` вызывает ошибку `KeyError`, потому что базовый словарь уже пуст.

### Проверка словарей на равенство

Когда вы проверяете два объекта `OrderedDict` на равенство в булевом контексте, порядок элементов играет важную роль. Например, если ваши упорядоченные словари содержат одинаковый набор элементов, то результат проверки зависит от их порядка:
```python
>>> from collections import OrderedDict
>>> letters_0 = OrderedDict(a=1, b=2, c=3, d=4)
>>> letters_1 = OrderedDict(b=2, a=1, c=3, d=4)
>>> letters_2 = OrderedDict(a=1, b=2, c=3, d=4)

>>> letters_0 == letters_1
False

>>> letters_0 == letters_2
True
```

В этом примере `letters_1` имеет небольшое различие в порядке элементов по сравнению с `letters_0` и `letters_2`, поэтому первый тест возвращает `False`. Во втором тесте `letters_0` и `letters_2` имеют одинаковый набор элементов, которые расположены в том же порядке, поэтому тест возвращает `True`.

Если вы попробуете повторить этот пример с обычными словарями, то получите другой результат:
```python
>>> letters_0 = dict(a=1, b=2, c=3, d=4)
>>> letters_1 = dict(b=2, a=1, c=3, d=4)
>>> letters_2 = dict(a=1, b=2, c=3, d=4)

>>> letters_0 == letters_1
True

>>> letters_0 == letters_2
True

>>> letters_0 == letters_1 == letters_2
True
```

Здесь, когда вы проверяете два обычных словаря на равенство, вы получаете `True`, если оба словаря имеют одинаковый набор элементов. В этом случае порядок элементов не влияет на конечный результат.

Наконец, тесты на равенство между объектом `OrderedDict` и обычным словарем не учитывают порядок элементов:
```python
>>> from collections import OrderedDict
>>> letters_0 = OrderedDict(a=1, b=2, c=3, d=4)
>>> letters_1 = dict(b=2, a=1, c=3, d=4)

>>> letters_0 == letters_1
True
```

Когда вы сравниваете упорядоченные словари с обычными словарями, порядок элементов не имеет значения. Если оба словаря имеют одинаковый набор элементов, то они будут сравниваться между собой одинаково, независимо от порядка элементов.

### Добавление новых атрибутов к экземпляру словаря

Объекты `OrderedDict` имеют атрибут `.__dict__`, который вы не найдете в обычных словарях. Взгляните на следующий код:
```python
>>> from collections import OrderedDict
>>> letters = OrderedDict(b=2, d=4, a=1, c=3)
>>> letters.__dict__
{}

>>> letters1 = dict(b=2, d=4, a=1, c=3)
>>> letters1.__dict__
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    letters1.__dict__
AttributeError: 'dict' object has no attribute '__dict__'
```

IВ первом примере вы обращаетесь к атрибуту `.__dict__` упорядоченного словаря `letters`. Python внутренне использует этот атрибут для хранения записываемых атрибутов экземпляра. Второй пример показывает, что объекты обычного словаря не имеют атрибута `.__dict__`.

Вы можете использовать атрибут `.__dict__` упорядоченного словаря для хранения динамически создаваемых записываемых атрибутов экземпляра. Существует несколько способов сделать это. Например, вы можете использовать присваивание в стиле словаря, как в `ordered_dict.__dict__["attr"] = value`. Можно также использовать точечную нотацию, как в `ordered_dict.attr = value`.

Вот пример использования `.__dict__` для присоединения новой функции к существующему упорядоченному словарю:
```python 
>>> from collections import OrderedDict
>>> letters = OrderedDict(b=2, d=4, a=1, c=3)

>>> letters.sorted_keys = lambda: sorted(letters.keys())
>>> vars(letters)
{'sorted_keys': <function <lambda> at 0x7fa1e2fe9160>}

>>> letters.sorted_keys()
['a', 'b', 'c', 'd']

>>> letters["e"] = 5
>>> letters.sorted_keys()
['a', 'b', 'c', 'd', 'e']
```

Теперь у вас есть `.sorted_keys()` [`lambda` функция](https://realpython.com/python-lambda/), присоединенная к вашему упорядоченному словарю `letters`. Обратите внимание, что вы можете просмотреть содержимое `.__dict__` либо обратившись к нему напрямую с помощью **точечной нотации**, либо используя [`vars()`](https://realpython.com/python-scope-legb-rule/#vars).

>**Примечание:** Этот вид динамического атрибута добавляется к определенному экземпляру данного класса. В приведенном выше примере таким экземпляром является `letters`. Это не влияет ни на другие экземпляры, ни на сам класс, поэтому доступ к `.sorted_keys()` вы имеете только через `letters`.

Вы можете использовать эту динамически добавляемую функцию для перебора ключей словаря в отсортированном порядке, не изменяя исходный порядок в `letters`:
```python
>>> for key in letters.sorted_keys():
...     print(key, "->", letters[key])
...
a -> 1
b -> 2
c -> 3
d -> 4
e -> 5

>>> letters
OrderedDict([('b', 2), ('d', 4), ('a', 1), ('c', 3), ('e', 5)])
```

Это лишь пример того, насколько полезной может быть эта функция `OrderedDict`. Обратите внимание, что вы не можете сделать что-то подобное с обычным словарем:
```python
>>> letters = dict(b=2, d=4, a=1, c=3)
>>> letters.sorted_keys = lambda: sorted(letters.keys())
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    letters.sorted_keys = lambda: sorted(letters.keys())
AttributeError: 'dict' object has no attribute 'sorted_keys'
```

Если вы попытаетесь динамически добавить пользовательские атрибуты экземпляра в обычный словарь, то получите сообщение `AttributeError`, говорящее о том, что в базовом словаре нет нужного атрибута. Это происходит потому, что у обычных словарей нет атрибута `.__dict__` для хранения новых атрибутов экземпляра.


## Слияние и обновление словарей с помощью операторов

[Python 3.9](https://realpython.com/python39-new-features/) добавил два новых оператора в пространство словарей. Теперь у вас есть операторы **merge** (`|`) и **update** (`|=`) словарей. Эти операторы также работают с экземплярами `OrderedDict`:
```python
Python 3.9.0 (default, Oct  5 2020, 17:52:02)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from collections import OrderedDict

>>> physicists = OrderedDict(newton="1642-1726", einstein="1879-1955")
>>> biologists = OrderedDict(darwin="1809-1882", mendel="1822-1884")

>>> scientists = physicists | biologists
>>> scientists
OrderedDict([
   ('newton', '1642-1726'),
   ('einstein', '1879-1955'),
   ('darwin', '1809-1882'),
   ('mendel', '1822-1884')
])
```

Как следует из названия, оператор merge объединяет два словаря в новый, содержащий элементы обоих исходных словарей. Если словари в выражении имеют общие ключи, то значения крайнего правого словаря будут преобладать.

Оператор update удобен, когда у вас есть словарь и вы хотите обновить некоторые его значения без вызова `.update()`:
```python
>>> physicists = OrderedDict(newton="1642-1726", einstein="1879-1955")

>>> physicists_1 = OrderedDict(newton="1642-1726/1727", hawking="1942-2018")
>>> physicists |= physicists_1
>>> physicists
OrderedDict([
    ('newton', '1642-1726/1727'),
    ('einstein', '1879-1955'),
    ('hawking', '1942-2018')
])
```

В этом примере вы используете оператор update словаря для обновления информации [Newton's lifetime](https://en.wikipedia.org/wiki/Isaac_Newton#cite_note-OSNS-3). Оператор обновляет словарь на месте. Если словарь, предоставляющий обновленные данные, имеет новые ключи, то эти ключи добавляются в конец исходного словаря.

## Учет производительности

Производительность - важная составляющая программирования. Знание того, как быстро работает алгоритм или сколько памяти он использует, является обычной потребностью. Изначально `OrderedDict` был [написан на Python] (https://github.com/python/cpython/blob/master/Lib/collections/__init__.py), а затем [написан на C] (https://github.com/python/cpython/blob/226a012d1cd61f42ecd3056c554922f359a1a35d/Objects/odictobject.c), чтобы максимизировать эффективность его методов и операций. Эти две реализации в настоящее время доступны в стандартной библиотеке. Однако реализация Python служит альтернативой, если реализация C по каким-то причинам недоступна.

Обе реализации `OrderedDict` предполагают использование [двусвязного списка](https://realpython.com/linked-lists-python/#how-to-use-doubly-linked-lists) для фиксации порядка элементов. Несмотря на линейное время для некоторых операций, реализация связанного списка в `OrderedDict` сильно оптимизирована, чтобы сохранить быстродействие соответствующих методов словаря. При этом операции над упорядоченным словарем выполняются как [_O_(1)](https://realpython.com/sorting-algorithms-python/#measuring-efficiency-with-big-o-notation), но с более высоким постоянным коэффициентом по сравнению с обычными словарями.

В целом, `OrderedDict` имеет более низкую производительность, чем обычные словари. Вот пример, в котором измеряется время выполнения нескольких операций над обоими классами словарей:
```python
# time_testing.py

from collections import OrderedDict
from time import perf_counter

def average_time(dictionary):
    time_measurements = []
    for _ in range(1_000_000):
        start = perf_counter()
        dictionary["key"] = "value"
        "key" in dictionary
        "missing_key" in dictionary
        dictionary["key"]
        del dictionary["key"]
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(1e9)

ordereddict_time = average_time(OrderedDict.fromkeys(range(1000)))
dict_time = average_time(dict.fromkeys(range(1000)))
gain = ordereddict_time / dict_time

print(f"OrderedDict: {ordereddict_time:.2f} ns")
print(f"dict:        {dict_time:.2f} ns ({gain:.2f}x faster)")
```

В этом скрипте вычисляется `average_time()`, которое требуется для выполнения нескольких обычных операций над заданным словарем. Цикл `for` использует [`time.pref_counter()`](https://docs.python.org/3/library/time.html#time.perf_counter) для измерения времени выполнения набора операций. Функция возвращает среднее время в наносекундах, которое требуется для выполнения выбранного набора операций.

>**Примечание:** Если вам интересно узнать другие способы определения времени выполнения кода, то вы можете ознакомиться с [Python Timer Functions: Three Ways to Monitor Your Code](https://realpython.com/python-timer/).

Если вы [запустите этот скрипт](https://realpython.com/run-python-scripts/) из командной строки, то получите результат, подобный этому:
```sh
$ python time_testing.py
OrderedDict: 272.93 ns
dict:        197.88 ns (1.38x faster)
```

Как видно из результатов, операции над объектами `dict` выполняются быстрее, чем операции над объектами `OrderedDict`.

Что касается потребления памяти, экземпляры `OrderedDict` вынуждены тратить ресурсы на хранение упорядоченного списка ключей. Вот сценарий, который дает представление об этих затратах памяти:
```python
>>> import sys
>>> from collections import OrderedDict

>>> ordereddict_memory = sys.getsizeof(OrderedDict.fromkeys(range(1000)))
>>> dict_memory = sys.getsizeof(dict.fromkeys(range(1000)))
>>> gain = 100 - dict_memory / ordereddict_memory * 100

>>> print(f"OrderedDict: {ordereddict_memory} bytes")
OrderedDict: 85408 bytes

>>> print(f"dict:        {dict_memory} bytes ({gain:.2f}% lower)")
dict:        36960 bytes (56.73% lower)
```

В этом примере вы используете [`sys.getsizeof()`](https://docs.python.org/3/library/sys.html?highlight=sys#sys.getsizeof) для измерения объема памяти в байтах двух объектов словаря. В выводе видно, что обычный словарь занимает меньше памяти, чем его аналог `OrderedDict`.

## Выбор правильного словаря для работы

Итак, вы узнали о существенных различиях между `OrderedDict` и `dict`. Вы узнали, что, несмотря на то, что обычные словари являются упорядоченными структурами данных, начиная с Python 3.6, использование `OrderedDict` все еще имеет определенную ценность из-за ряда полезных возможностей, которые отсутствуют в `dict`.

Вот краткий обзор наиболее значимых различий и особенностей обоих классов, которые следует учитывать при принятии решения о том, какой из них использовать:

| Функционал | `OrderedDict` | `dict` |  |
| ---- | ---- | ---- | ---- |
| Поддержка порядка вставки ключей | Да ( начиная с Python 3.1) | Да ( начиная с Python 3.6) |  |
| Читабельность и предупреждение о намерениях относительно порядка элементов | Высокий | Низкий | Низкий |
| Контроль над порядком элементов | Высокий (`.move_to_end()`, улучшенный `.popitem()`) | Низкий (требуется удаление и повторная вставка элементов). |  |
| Производительность операций | Низкая | Высокая | Высокая |
| Потребление памяти | Высокое | Низкое |  |
| Тесты равенства учитывают порядок элементов | Да | Нет |  |
| Поддержка обратной итерации | Да (начиная с Python 3.5) | Да (начиная с Python 3.8) | Да. |
| Возможность добавлять новые атрибуты экземпляра | Да (атрибут `.__dict__`) | Нет |  |
| Поддержка операторов слияния ( \| ) | и обновления ( \|= ) словарей | Да (начиная с Python 3.9) | Да (начиная с Python 3.9) |

В этой таблице приведены некоторые основные различия между `OrderedDict` и `dict`, которые следует учитывать, когда вам нужно выбрать класс словаря для решения проблемы или реализации определенного алгоритма. В общем, если порядок элементов в словаре жизненно важен или даже необходим для корректной работы вашего кода, то в первую очередь вам следует обратить внимание на `OrderedDict`.

## Построение очереди на основе словаря

Случай, в котором вам следует рассмотреть использование объекта `OrderedDict`, а не объекта `dict` - это когда вам нужно реализовать [очередь] на основе словаря (https://en.wikipedia.org/wiki/Queue_(abstract_data_type)). Очереди - это распространенные и полезные структуры данных, которые управляют своими элементами по принципу FIFO. Это означает, что вы вставляете новые элементы в конец очереди, а старые элементы вынимаете из начала очереди.

Обычно очереди реализуют операцию добавления элемента в конец очереди, которая известна как операция **enqueue**. Очереди также реализуют операцию удаления элементов из их начала, которая известна как операция **dequeue**.

Чтобы создать очередь на основе словаря, откройте ваш [редактор кода или IDE](https://realpython.com/python-ides-code-editors-guide/), создайте новый модуль Python под названием `queue.py` и добавьте в него следующий код:
```python
# queue.py

from collections import OrderedDict

class Queue:
    def __init__(self, initial_data=None, /, **kwargs):
        self.data = OrderedDict()
        if initial_data is not None:
            self.data.update(initial_data)
        if kwargs:
            self.data.update(kwargs)

    def enqueue(self, item):
        key, value = item
        if key in self.data:
            self.data.move_to_end(key)
        self.data[key] = value

    def dequeue(self):
        try:
            return self.data.popitem(last=False)
        except KeyError:
            print("Empty queue")

    def __len__(self):
        return len(self.data)

    def __repr__(self):
        return f"Queue({self.data.items()})"
```

В `Queue` вы сначала инициализируете [атрибут экземпляра](https://realpython.com/python3-object-oriented-programming/#class-and-instance-attributes) под названием `.data`. Этот атрибут содержит пустой упорядоченный словарь, который вы будете использовать для хранения данных. Инициализатор класса принимает первый необязательный аргумент, `initial_data`, который позволяет вам предоставить начальные данные при инстанцировании класса. Инициализатор также принимает необязательные аргументы ключевых слов ([`kwargs`](https://realpython.com/python-kwargs-and-args/)), чтобы вы могли использовать аргументы ключевых слов в конструкторе.

Затем вы разрабатываете код `.enqueue()`, который позволяет вам добавлять пары ключ-значение в очередь. В этом случае вы используете `.move_to_end()`, если ключ уже существует, и используете обычное присваивание для новых ключей. Обратите внимание, что для работы этого метода необходимо предоставить двухэлементный `tuple` или `list` с допустимой парой ключ-значение.

Реализация `.dequeue()` использует `.popitem()` с `last`, установленным в `False`, для удаления и возврата элементов из начала исходного упорядоченного словаря `.data`. В этом случае используется блок [`try` ... `except`](https://realpython.com/python-exceptions/#the-try-and-except-block-handling-exceptions) для обработки `KeyError`, возникающей при вызове `.popitem()` на пустом словаре.

Специальный метод [`.__len__()`](https://docs.python.org/3/reference/datamodel.html#object.__len__) обеспечивает необходимую функциональность для получения длины упорядоченного словаря `.data`. Наконец, специальный метод [`.__repr__()`](https://realpython.com/operator-function-overloading/#representing-your-objects-using-repr) обеспечивает удобное для пользователя **строковое представление** очереди при выводе структуры данных на экран.

Вот несколько примеров того, как можно использовать `Queue`:
```python
>>> from queue import Queue

>>> # Создание пустой очереди
>>> empty_queue = Queue()
>>> empty_queue
Queue(odict_items([]))

>>> # Создание очереди с начальными данными
>>> numbers_queue = Queue([("one", 1), ("two", 2)])
>>> numbers_queue
Queue(odict_items([('one', 1), ('two', 2)]))

>>> # Создание очереди с аргументами в виде ключевых слов
>>> letters_queue = Queue(a=1, b=2, c=3)
>>> letters_queue
Queue(odict_items([('a', 1), ('b', 2), ('c', 3)]))

>>> # Добавление элементов
>>> numbers_queue.enqueue(("three", 3))
>>> numbers_queue
Queue(odict_items([('one', 1), ('two', 2), ('three', 3)]))

>>> # Удаление элементов
>>> numbers_queue.dequeue()
('one', 1)
>>> numbers_queue.dequeue()
('two', 2)
>>> numbers_queue.dequeue()
('three', 3)
>>> numbers_queue.dequeue()
Empty queue
```

В этом примере кода вы сначала создаете три разных объекта `Queue`, используя различные подходы. Затем вы используете `.enqueue()` для добавления одного элемента в конец `numbers_queue`. Наконец, вы вызываете `.dequeue()` несколько раз, чтобы удалить все элементы в `numbers_queue`. Обратите внимание, что последний вызов `.dequeue()` выводит на экран сообщение о том, что очередь уже пуста.

## Заключение

В течение многих лет словари Python были неупорядоченными структурами данных. Это выявило необходимость в упорядоченном словаре, который поможет в ситуациях, когда **порядок элементов** важен. Поэтому разработчики Python создали [`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict), который был специально разработан для упорядочивания элементов.

Python 3.6 привнес новую возможность в обычные словари. Теперь они также запоминают порядок элементов. С этим дополнением большинство программистов Python задаются вопросом, нужно ли им еще использовать `OrderedDict`.

**В этом руководстве вы узнали:**.

- Как создавать и использовать объекты **`OrderedDict`** в вашем коде
- В чем основные **различия** между `OrderedDict` и `dict`
- В чем **плюсы** и **минусы** использования `OrderedDict` и `dict`.

Теперь у вас есть возможность принять взвешенное решение об использовании `dict` или `OrderedDict`, если вашему коду нужен упорядоченный словарь.

В этом руководстве вы написали пример реализации очереди на основе словаря, который показывает, что `OrderedDict` все еще может быть полезен в ваших ежедневных приключениях по написанию кода на Python.