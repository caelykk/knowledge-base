[Орининальная статья (Real Python, eng, 2021)](https://realpython.com/python-namedtuple/)

Python модуль`collections` предоставляет фабричную функцию namedtuple(), которая специально разработана для того, чтобы сделать ваш код более питонистым при работе с кортежами. С помощью namedtuple() можно создавать неизменяемые типы последовательностей, которые позволяют обращаться к их значениям, используя имена полей и точечную нотацию вместо невнятных целочисленных индексов.

Если у вас есть некоторый опыт работы с Python, то вы знаете, что написание понятного кода является основным навыком для разработчиков на Python. В этом материале вы повысите уровень этого навыка, используя namedtuple.

В этом уроке вы узнаете, как:

- Создавать классы namedtuple с помощью функции namedtuple().
- Определять и использовать преимущества крутых возможностей namedtuple
- Использовать экземпляры namedtuple для написания Pythonic-кода
- Решать, использовать namedtuple или аналогичную структуру данных.
- Создавать подклассы namedtuple для обеспечения новых возможностей

## Использование `namedtuple` для написания питонского кода

Python [`namedtuple()`](https://docs.python.org/3/library/collections.html#collections.namedtuple) is a [factory function](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)), доступна в [`collections`](https://docs.python.org/3/library/collections.html#module-collections). Она позволяет создавать подклассы `tuple` с **именованными полями**. Вы можете получить доступ к значениям в данном именованном кортеже, используя **точечную нотацию** и имена полей, как в `obj.attr`.

Python `namedtuple` был создан для улучшения читаемости кода путем предоставления возможности доступа к значениям с использованием имен полей вместо целочисленных индексов, которые в большинстве случаев не дают никакого представления о том, что представляют собой эти значения. Эта особенность также делает код более чистым и удобным для поддержки.

Напротив, использование индексов для значений в обычном кортеже может быть неудобным, трудночитаемым и чреватым ошибками. Особенно это касается тех случаев, когда кортеж имеет много полей и формируется далеко от того места, где вы его используете.

>**Примечание:** В этом руководстве вы встретите различные термины, используемые для обозначения `namedtuple` в Python, его фабричной функции и его экземпляров.
>
Чтобы избежать путаницы, вот краткое описание того, как каждый термин используется в этом учебнике:

| **Термин** | **Значение** |
| ------------------------------------------ | ------------------------------------------------------- |
| `namedtuple()`                             | Фабричная функция                                       |
| `namedtuple`, класс `namedtuple`           | Подкласс кортежа, возвращаемый функцией `namedtuple()`. |
| экземпляр `namedtuple`, именованный кортеж | Экземпляр класса `namedtuple`.                          |

Эти термины с соответствующим значением вы будете использовать на протяжении всего руководства.

Помимо этой главной особенности именованных кортежей, вы узнаете, что они:
- Являются ** неизменяемыми** структурами данных
- Имеют постоянное [хэш](https://docs.python.org/3/library/functions.html#hash) значение
- Могут использоваться как **ключи словаря**
- Могут храниться в [множествах](https://realpython.com/python-sets/)
- Имеют полезную [docstring](https://realpython.com/documenting-python-code/), основанную на типе и именах полей.
- Предоставляют полезное **строковое представление**, которое выводит содержимое кортежа в формате `имя=значение`.
- Поддерживают **индексацию**
- Предоставляют дополнительные методы и атрибуты, такие как [`._make()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._make), [`_asdict()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._asdict), [`._fields`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._fields) и т.д.
- Являются **обратно совместимыми** с обычными кортежами
- Имеют **сходное потребление памяти** с обычными кортежами

В общем, вы можете использовать экземпляры `namedtuple` везде, где вам нужен кортежеподобный объект. Преимущество именованных кортежей в том, что они предоставляют возможность доступа к своим значениям с помощью имен полей и точечной нотации. Это сделает ваш код более Pythonic.

После этого краткого введения в `namedtuple` и его общие возможности, вы сможете более глубоко погрузиться в создание и использование их в своем коде.


## Создание кортежеподобных классов с помощью функции namedtuple()

Вы используете `namedtuple()` для создания [неизменяемой](https://docs.python.org/3/glossary.html#term-immutable) и кортежеподобной структуры данных с именами полей. Популярный пример, который вы найдете в учебниках по `namedtuple`, - это создание класса для представления математической [точки](https://en.wikipedia.org/wiki/Point_(geometry)).

В зависимости от задачи, вы, вероятно, захотите использовать неизменяемую структуру данных для представления данной точки. Вот как можно создать двумерную точку с помощью обычного кортежа:
```python
# Создание двумерной точки в виде кортежа
>>> point = (2, 4)
>>> point
(2, 4)

>>> # Доступ к координате x
>>> point[0]
2
>>> # Доступ к координате y
>>> point[1]
4

>>> # Попытка обновить значение координаты
>>> point[0] = 3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

Здесь вы создаете неизменяемую двумерную `point`, используя обычный `tuple`. Этот код работает: У вас есть `point` с двумя координатами, и вы не можете изменить ни одну из этих координат. Однако, является ли этот код читабельным? Можете ли вы сразу сказать, что означают индексы `0` и `1`? Чтобы избежать подобных двусмысленностей, вы можете использовать `namedtuple` следующим образом:
```python
from collections import namedtuple

>>> # Создание именованного кортежа, Point
>>> Point = namedtuple("Point", "x y")
>>> issubclass(Point, tuple)
True

>>> # Создание экземпляра класса именованного кортежа
>>> point = Point(2, 4)
>>> point
Point(x=2, y=4)

>>> # Точечная нотация для доступа к координатам
>>> point.x
2
>>> point.y
4

>>> # Индексация для доступа к координатам
>>> point[0]
2
>>> point[1]
4

>>> # Именованные кортежи являются неизменяемыми
>>> point.x = 100
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
```

Теперь у вас есть точка с двумя соответствующим образом названными полями, `x` и `y`. По умолчанию ваша точка имеет удобное и наглядное представление (`Point(x=2, y=4)`). Это позволяет вам обращаться к координатам, используя точечную нотацию, которая удобна, читабельна и явна. Вы также можете использовать индексы для доступа к значению каждой координаты.

>**Примечание:** Важно отметить, что, хотя кортежи и именованные кортежи являются неизменяемыми, значения, которые они хранят, не обязательно должны быть неизменяемыми.

Вполне допустимо создать кортеж или именованный кортеж, который хранит изменяемые значения:
```python
from collections import namedtuple

>>> Person = namedtuple("Person", "name children")
>>> john = Person("John Doe", ["Timmy", "Jimmy"])
>>> john
Person(name='John Doe', children=['Timmy', 'Jimmy'])
>>> id(john.children)
139695902374144

>>> john.children.append("Tina")
>>> john
Person(name='John Doe', children=['Timmy', 'Jimmy', 'Tina'])
>>> id(john.children)
139695902374144

>>> hash(john)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

>Вы можете создавать именованные кортежи, содержащие изменяемые объекты. Вы можете изменять изменяемые объекты в кортеже. Однако это не означает, что вы изменяете сам кортеж. Кортеж будет по-прежнему содержать те же ссылки на память.
>
Наконец, кортежи или именованные кортежи с изменяемыми значениями не являются [хэшируемыми](https://docs.python.org/3/glossary.html#term-hashable), как вы видели в приведенном выше примере.

Наконец, поскольку классы `namedtuple` являются подклассами `tuple`, они также неизменяемы. Поэтому если вы попытаетесь изменить значение координаты, то получите ошибку `AttributeError`.

### Передача обязательных аргументов в `namedtuple()

Как вы уже узнали, `namedtuple()` - это фабричная функция, а не типичная структура данных. Чтобы создать новый `namedtuple`, необходимо предоставить функции два позиционных аргумента:

1.  **`typename`** задает имя класса для `namedtuple`, возвращаемого функцией `namedtuple()`. В этот аргумент нужно передать строку с [допустимым идентификатором Python](https://doc.python.org/3/reference/lexical_analysis.html#identifiers).
2.  **`field_names`** содержит имена полей, которые вы будете использовать для доступа к значениям в кортеже. Вы можете указать имена полей, используя:
	- [итерируемую](https://docs.python.org/3/glossary.html#term-iterable) последовательность строк, например `["field1", "field2", ..., "fieldN"]`.
	- Строку с именами полей, разделенных пробелами, например, `"field1 field2 ... fieldN"`.
	- Строку с именами полей, разделенных запятыми, например, `"field1, field2, ..., fieldN"`.

Для иллюстрации того, как задавать имена полей, приведем различные способы создания точек:
```python
from collections import namedtuple

>>> # Список строк с именами полей
>>> Point = namedtuple("Point", ["x", "y"])
>>> Point
<class '__main__.Point'>
>>> Point(2, 4)
Point(x=2, y=4)

>>> # Строка с именами полей, разделенных запятыми
>>> Point = namedtuple("Point", "x, y")
>>> Point
<class '__main__.Point'>
>>> Point(4, 8)
Point(x=4, y=8)

>>> # Выражение генератора для имен полей
>>> Point = namedtuple("Point", (field for field in "xy"))
>>> Point
<class '__main__.Point'>
>>> Point(8, 16)
Point(x=8, y=16)
```

В этих примерах вы сначала создаете `Point`, используя список имен полей. Затем вы используете строку с именами полей, разделенных запятыми. Наконец, вы используете выражение-генератор. Последний вариант может показаться излишним в данном примере. Однако он предназначен для иллюстрации гибкости процесса.

>**Примечание:** Если вы используете итерируемый объект для задания имен полей, то вам следует использовать объект, подобный последовательности, поскольку порядок полей важен для получения надежных результатов.
>
Например, использование множества (`set`) будет работать, но может привести к неожиданным результатам:
>```python
from collections import namedtuple
>
>>> Point = namedtuple("Point", {"x", "y"})
>>> Point(2, 4)
Point(y=2, x=4)
>```
>
Когда вы используете неупорядоченный итерируемый объект для предоставления полей именованного кортежа, вы можете получить неожиданные результаты. В приведенном выше примере имена координат поменялись местами, что может не подойти для вашего случая использования.

Вы можете использовать любой допустимый идентификатор Python для имен полей, за исключением:

- Имен, начинающихся с символа подчеркивания (`_`)
- [`ключевых слов`](https://realpython.com/python-keywords/) Python

Если вы передаете имена полей, которые нарушают одно из этих условий, то вы получите ошибку `ValueError`:
```python
from collections import namedtuple

>>> Point = namedtuple("Point", ["x", "_y"])
Traceback (most recent call last):
  ...
ValueError: Field names cannot start with an underscore: '_y'
```

В этом примере имя второго поля начинается с символа подчеркивания, поэтому вы получаете `ValueError`, сообщающий вам, что имена полей не могут начинаться с этого символа. Это сделано для того, чтобы избежать конфликтов имен с методами и атрибутами `namedtuple`.

Если посмотреть на приведенные выше примеры, то в случае с `typename` может возникнуть вопрос: Почему мне нужно указывать аргумент `typename`? Ответ заключается в том, что вам нужно имя для класса, возвращаемого функцией `namedtuple()`. Это похоже на создание псевдонима для существующего класса:
```python
from collections import namedtuple

>>> Point1 = namedtuple("Point", "x y")
>>> Point1
<class '__main__.Point'>

>>> class Point:
...     def __init__(self, x, y):
...         self.x = x
...         self.y = y
...

>>> Point2 = Point
>>> Point2
<class '__main__.Point'>
```

В первом примере вы создаете `Point` с помощью `namedtuple()`. Затем вы присваиваете этот новый тип [глобальной](https://realpython.com/python-scope-legb-rule/#modules-the-global-scope) [переменной](https://realpython.com/python-variables/) `Point1`. Во втором примере вы создаете обычный класс Python с именем `Point`, а затем присваиваете класс переменной `Point2`. В обоих случаях имя класса - `Point`. `Point1` и `Point2` являются псевдонимами для рассматриваемого класса.

Наконец, вы также можете создать именованный кортеж, используя ключевые аргументы или передав существующий словарь, например, так:
```python
from collections import namedtuple

>>> Point = namedtuple("Point", "x y")

>>> Point(x=2, y=4)
Point(x=2, y=4)

>>> Point(**{"x": 4, "y": 8})
Point(x=4, y=8)
```

IВ первом примере для создания объекта `Point` используются ключевые аргументы. Во втором примере вы используете словарь, ключи которого соответствуют полям `Point`. В этом случае необходимо выполнить **распаковку словаря**.


### Использование необязательных аргументов с `namedtuple()`

Кроме двух обязательных аргументов, фабричная функция `namedtuple()` также принимает следующие необязательные аргументы:

- `rename`
- `defaults`
- `module`.

#### rename

Если вы установите `rename` в `True`, то все недопустимые имена полей будут автоматически заменены на позиционные имена.

Скажем, в вашей компании есть старое приложение базы данных, написанное на Python, для управления данными о пассажирах, которые путешествуют вместе с компанией. Вас попросили обновить систему, и вы начинаете создавать именованные кортежи для хранения данных, которые вы считываете из базы данных.

Приложение предоставляет функцию `get_column_names()`, которая возвращает список строк с именами столбцов, и вы думаете, что можете использовать эту функцию для создания класса `namedtuple`. В итоге у вас получился следующий код:
```python
# passenger.py

from collections import namedtuple

from database import get_column_names

Passenger = namedtuple("Passenger", get_column_names())
```

Однако при выполнении кода возникает [exception traceback](https://realpython.com/python-traceback/), как показано ниже:
```python
Traceback (most recent call last):
  ...
ValueError: Type names and field names cannot be a keyword: 'class'
```

Это говорит вам о том, что имя столбца `class` не является допустимым именем поля для вашего класса `namedtuple`. Чтобы предотвратить эту ситуацию, вы решаете использовать `rename`:
```python
# passenger.py

# ...

Passenger = namedtuple("Passenger", get_column_names(), rename=True)
```

Это заставляет `namedtuple()` автоматически заменять недопустимые имена на позиционные. Теперь предположим, что вы извлекли одну строку из базы данных и создали свой первый экземпляр `Passenger` следующим образом:
```python
from passenger import Passenger
>>> from database import get_passenger_by_id

>>> Passenger(get_passenger_by_id("1234"))
Passenger(_0=1234, name='john', _2='Business', _3='John Doe')
```

IВ данном случае `get_passenger_by_id()` - это еще одна функция, доступная в вашем гипотетическом приложении. Она извлекает данные для определенного пассажира в виде кортежа. В итоге ваш вновь созданный пассажир имеет три позиционных имени полей, и только `name` отражает исходное имя столбца. Когда вы копаетесь в базе данных, вы понимаете, что таблица passengers имеет следующие столбцы:

| Колонка  | Содержание                                   | Заменяется? | Причина                          |
| ------- | ---------------------------------------- | --------- | ------------------------------- |
| `_id`   | Уникальный идентификатор для каждого пассажира   | Да       | Начинается с нижнего подчеркивания.   |
| `name`  | Короткое имя каждого пассажира          | Нет        | Это допустимый идентификатор Python. |
| `class` | Класс, которым путешествует пассажир | Да       | Это ключевое слово языка Python.          |
| `name`  | Полное имя пассажира                | Да       | Оно повторяется.                  |

В ситуациях, когда вы создаете именованные кортежи на основе значений, находящихся вне вашего контроля, опция `rename` должна быть установлена в `True`, чтобы недопустимые имена полей были переименованы в допустимые позиционные имена.

#### defaults

Вторым необязательным аргументом для `namedtuple()` является `defaults`. Этот аргумент по умолчанию имеет значение [`None`](https://realpython.com/null-in-python/), что означает, что поля не будут иметь значений по умолчанию. Вы можете задать `defaults` в виде итерации значений. В этом случае функция `namedtuple()` присваивает крайним правым полям значения из итерации `defaults`:
```python
from collections import namedtuple

>>> Developer = namedtuple(
...     "Developer",
...     "name level language",
...     defaults=["Junior", "Python"]
... )

>>> Developer("John")
Developer(name='John', level='Junior', language='Python')
```

В этом примере поля `level` и `language` имеют значения по умолчанию. Это делает их необязательными аргументами. Поскольку вы не определили значение по умолчанию для `name`, вам необходимо указать значение при создании экземпляра `namedtuple`. Таким образом, аргументы без значения по умолчанию являются обязательными. Обратите внимание, что значения по умолчанию применяются к крайним правым полям.

#### module

Последним аргументом в `namedtuple()` является `module`. Если вы указали в этом аргументе допустимое имя модуля, то атрибут `.__module__` результирующего `namedtuple` будет установлен в это значение. Этот атрибут содержит имя модуля, в котором определена данная функция или вызываемый модуль:
```python
from collections import namedtuple

>>> Point = namedtuple("Point", "x y", module="custom")
>>> Point
<class 'custom.Point'>
>>> Point.__module__
'custom'
```

In this example, when you access `.__module__` on `Point`, you get `'custom'` as a result. This indicates that your `Point` class is defined in your `custom` module.

The [motivation](https://bugs.python.org/issue17941) to add the `module` argument to `namedtuple()` in [Python 3.6](https://docs.python.org/3/whatsnew/3.6.html#collections) was to make it possible for named tuples to support [pickling](https://realpython.com/python-pickle-module/) through different [Python implementations](https://docs.python.org/3/reference/introduction.html?highlight=ironpython#alternate-implementations).

## Изучение дополнительных возможностей классов `namedtuple`

Помимо методов, унаследованных от `tuple`, таких как `.count()` и `.index()`, классы `namedtuple` предоставляют три дополнительных метода и два атрибута. Чтобы предотвратить конфликты имен с пользовательскими полями, имена этих атрибутов и методов начинаются с нижнего подчеркивания. В этом разделе вы узнаете об этих методах и атрибутах и о том, как они работают.

### Создание экземпляров `namedtuple` из итерируемых объектов

Вы можете использовать [`._make()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._make) для создания экземпляров именованных кортежей. Метод принимает итерируемый объект и возвращает новый именованный кортеж:
```python
from collections import namedtuple

>>> Person = namedtuple("Person", "name age height")
>>> Person._make(["Jane", 25, 1.75])
Person(name='Jane', age=25, height=1.75)
```

Здесь вы сначала создаете класс `Person` с помощью `namedtuple()`. Затем вы вызываете `._make()` со списком значений для каждого поля в `namedtuple`. Обратите внимание, что `._make()` - это [метод класса](https://realpython.com/instance-class-and-static-methods-demystified/), который работает как альтернативный [конструктор класса](https://realpython.com/python-class-constructor/) и возвращает новый экземпляр именованного кортежа.

Наконец, `._make()` ожидает в качестве аргумента одну итерируемый объект В приведенном выше примере это список. С другой стороны, конструктор `namedtuple` может принимать позиционные или ключевые аргументы, как мы уже знаем.

### Преобразование экземпляров `namedtuple` в словари

Вы можете преобразовать существующие экземпляры именованных кортежей в словари, используя [`._asdict()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._asdict). Этот метод возвращает новый словарь, в котором в качестве ключей используются имена полей. Ключи полученного словаря располагаются в том же порядке, что и поля в исходном `namedtuple`:
```python
from collections import namedtuple

>>> Person = namedtuple("Person", "name age height")
>>> jane = Person("Jane", 25, 1.75)
>>> jane._asdict()
{'name': 'Jane', 'age': 25, 'height': 1.75}
```

Когда вы вызываете `._asdict()` для именованного кортежа, вы получаете новый объект `dict`, который сопоставляет имена полей с соответствующими значениями в исходном именованном кортеже.

Начиная с [Python 3.8](https://realpython.com/python38-new-features/), `._asdict()` возвращает обычный словарь. До этого он возвращал объект [`OrderedDict`](https://realpython.com/python-ordereddict/):
```python
Python 3.7.9 (default, Jan 14 2021, 11:41:20)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from collections import namedtuple

>>> Person = namedtuple("Person", "name age height")
>>> jane = Person("Jane", 25, 1.75)
>>> jane._asdict()
OrderedDict([('name', 'Jane'), ('age', 25), ('height', 1.75)])
```

[Python 3.8 updated `._asdict()`](https://docs.python.org/3/whatsnew/3.8.html#collections) to return a regular dictionary because dictionaries remember the insertion order of their keys in Python 3.6 and up. Note that the order of keys in the resulting dictionary is equivalent to the order of fields in the original named tuple.

### Замена полей в существующих экземплярах `namedtuple`

Последний метод, с которым вы познакомитесь, это [`._replace()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._replace). Этот метод принимает ключевые аргументы вида `field=value` и возвращает новый экземпляр `namedtuple`, обновляя значения выбранных полей:
```python
from collections import namedtuple

>>> Person = namedtuple("Person", "name age height")
>>> jane = Person("Jane", 25, 1.75)

>>> # После дня рождения Джейн
>>> jane = jane._replace(age=26)
>>> jane
Person(name='Jane', age=26, height=1.75)
```

В этом примере вы обновляете возраст Джейн после ее дня рождения. Хотя название `._replace()` может навести на мысль, что метод изменяет существующий именованный кортеж, на практике это не так. Это происходит потому, что экземпляры `namedtuple` неизменяемы, поэтому `._replace()` не обновляет `jane` [на месте](https://en.wikipedia.org/wiki/In-place_algorithm).

### Изучение дополнительных атрибутов `namedtuple`

Именованные кортежи также имеют два дополнительных атрибута: [`._fields`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._fields) и [`._field_defaults`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._field_defaults). Первый атрибут содержит кортеж строк, перечисляющих имена полей. Второй атрибут содержит словарь, который сопоставляет имена полей с их соответствующими значениями по умолчанию, если таковые имеются.

В случае с `._fields` вы можете использовать его для [интроспекции](https://pythonist.ru/introspekcziya-v-python/) своих классов и экземпляров `namedtuple`. Вы также можете создавать новые классы на основе существующих:
```python
from collections import namedtuple

>>> Person = namedtuple("Person", "name age height")

>>> ExtendedPerson = namedtuple(
...     "ExtendedPerson",
...     [*Person._fields, "weight"]
... )

>>> jane = ExtendedPerson("Jane", 26, 1.75, 67)
>>> jane
ExtendedPerson(name='Jane', age=26, height=1.75, weight=67)
>>> jane.weight
67
```

В этом примере вы создаете новый `namedtuple` под названием `ExtendedPerson` с новым полем `weight`. Этот новый тип расширяет ваш старый `Person`. Для этого вы обращаетесь к `._fields` на `Person` и распаковываете его в новый список вместе с дополнительным полем `weight`.

Вы также можете использовать `._fields` для итерации полей и значений в данном экземпляре `namedtuple`, используя Python [`zip()`](https://realpython.com/python-zip-function/):
```python
from collections import namedtuple

>>> Person = namedtuple("Person", "name age height weight")
>>> jane = Person("Jane", 26, 1.75, 67)
>>> for field, value in zip(jane._fields, jane):
...     print(field, "->", value)
...
name -> Jane
age -> 26
height -> 1.75
weight -> 67
```

В этом примере `zip()` создает кортежи вида `(field, value)`. Таким образом, вы можете получить доступ к обоим элементам пары поле-значение в именованном кортеже. Другим способом одновременного перебора полей и значений может быть использование `._asdict().items()`. Попробуйте и вы!

С помощью `._field_defaults` вы можете интроспектировать классы и экземпляры `namedtuple`, чтобы узнать, какие поля имеют значения по умолчанию. Наличие значений по умолчанию делает ваши поля необязательными. Допустим, ваш класс `Person` должен содержать дополнительное поле для указания страны, в которой живет человек. Поскольку вы в основном работаете с людьми из Канады, вы устанавливаете соответствующее значение по умолчанию для поля `country` следующим образом:
```python
from collections import namedtuple

>>> Person = namedtuple(
...     "Person",
...     "name age height weight country",
...     defaults=["Canada"]
... )

>>> Person._field_defaults
{'country': 'Canada'}
```

С помощью быстрого запроса к `._field_defaults` вы можете выяснить, какие поля в данном именованном кортеже имеют значения по умолчанию. В этом примере любой другой программист из вашей команды может увидеть, что ваш класс `Person` содержит `"Canada"` в качестве значения по умолчанию для `country`.

Если ваш `namedtuple` не предоставляет значений по умолчанию, то `.field_defaults` содержит пустой словарь:
```python
from collections import namedtuple

>>> Person = namedtuple("Person", "name age height weight country")
>>> Person._field_defaults
{}
```

Если вы не указали список значений по умолчанию в `namedtuple()`, то он полагается на значение по умолчанию в `defaults`, которое является [`None`](https://realpython.com/null-in-python/). В этом случае `._field_defaults` содержит пустой словарь.

## Написание питонского кода с помощью `namedtuple`

Пожалуй, основная цель использования именованных кортежей - помочь вам писать более питонский код. Фабричная функция `namedtuple()` была создана для того, чтобы вы могли писать читаемый, явный, чистый и сопровождаемый код.

В этом разделе вы напишете множество практических примеров, которые помогут вам найти хорошие возможности для использования именованных кортежей вместо обычных кортежей, чтобы сделать ваш код более питонским.

### Использование имен полей вместо индексов

Допустим, вы создаете приложение для рисования, и вам нужно определить свойства пера, которые будут использоваться в зависимости от выбора пользователя. Вы задали свойства пера в виде кортежа:
```python
pen = (2, "Solid", True)

>>> if pen[0] == 2 and pen[1] == "Solid" and pen[2]:
...     print("Standard pen selected")
...
Standard pen selected
```

Эта строка кода определяет кортеж с тремя значениями. Можете ли вы сказать, что означает каждое значение? Возможно, вы догадаетесь, что второе значение связано со стилем линии, но каково значение `2` и `True`?

Вы можете добавить хороший комментарий, чтобы обеспечить некоторый контекст для `pen`, и в этом случае вы получите что-то вроде этого:
```python
# Tuple containing: line weight, line style, and beveled edges
>>> pen = (2, "Solid", True)
```

Круто! Теперь вы знаете значение каждого значения в кортеже. Однако, что если вы или другой программист используете `pen` далеко от этого определения? Им придется вернуться к определению, чтобы вспомнить, что означает каждое значение.

Вот альтернативная реализация `pen` с использованием `namedtuple`:
```python
from collections import namedtuple

>>> Pen = namedtuple("Pen", "width style beveled")
>>> pen = Pen(2, "Solid", True)

>>> if pen.width == 2 and pen.style == "Solid" and pen.beveled:
...     print("Standard pen selected")
...
Standard pen selected
```

Теперь ваш код ясно показывает, что `2` представляет ширину пера, `"Solid"` - стиль линии, и так далее. Любой, кто читает ваш код, может увидеть и понять это. Ваша новая реализация `pen` состоит из двух дополнительных строк кода. Это небольшой объем работы, который дает большой выигрыш с точки зрения читабельности и сопровождаемости.

### Возвращение нескольких именованных значений из функций

Другая ситуация, в которой вы можете использовать именованный кортеж, - это когда вам нужно [вернуть несколько значений](https://realpython.com/python-return-statement/#returning-multiple-named-objects) из заданной функции. В этом случае использование именованного кортежа может сделать ваш код более читабельным, поскольку возвращаемые значения также будут содержать некоторый контекст для их содержания.

Например, Python предоставляет встроенную функцию [`divmod()`](https://docs.python.org/3/library/functions.html#divmod), которая принимает два числа в качестве аргументов и возвращает кортеж с **коэффициентом** и **остатком**, которые получаются в результате целочисленного деления входных чисел:
```python
divmod(8, 4)
(2, 0)
```

Чтобы запомнить значение каждого числа, вам, возможно, придется прочитать документацию к `divmod()`, поскольку сами числа не дают много информации об их индивидуальном значении. Название функции тоже не очень-то помогает.

Вот функция, использующая `именованный кортеж` для уточнения значения каждого числа, которое возвращает `divmod()`:
```python
from collections import namedtuple

>>> def custom_divmod(a, b):
...     DivMod = namedtuple("DivMod", "quotient remainder")
...     return DivMod(*divmod(a, b))
...

>>> custom_divmod(8, 4)
DivMod(quotient=2, remainder=0)
```

В этом примере вы добавляете контекст к каждому возвращаемому значению, чтобы любой программист, читающий ваш код, мог сразу понять, что означает каждое число.


### Сокращение количества аргументов в функциях

Сокращение числа аргументов, которые может принимать функция, считается лучшей практикой программирования. Это делает сигнатуру функции более лаконичной и оптимизирует процесс [тестирования](https://realpython.com/python-testing/) из-за уменьшения количества аргументов и возможных комбинаций между ними.

И в этом случае вам следует рассмотреть возможность использования именованных кортежей. Допустим, вы разрабатываете приложение для управления информацией о своих клиентах. Приложение использует базу данных для хранения данных клиентов. Для обработки данных и обновления базы данных вы создали несколько функций. Одна из ваших функций высокого уровня - `create_user()`, которая выглядит следующим образом:
```python
def create_user(db, username, client_name, plan):
    db.add_user(username)
    db.complete_user_profile(username, client_name, plan)
```

Эта функция принимает четыре аргумента. Первый аргумент, `db`, представляет базу данных, с которой вы работаете. Остальные аргументы тесно связаны с конкретным клиентом. Это отличная возможность сократить количество аргументов для `create_user()`, используя именованный кортеж:
```python
User = namedtuple("User", "username client_name plan")
user = User("john", "John Doe", "Premium")

def create_user(db, user):
    db.add_user(user.username)
    db.complete_user_profile(
        user.username,
        user.client_name,
        user.plan
    )
```

Теперь `create_user()` принимает только два аргумента: `db` и `user`. Внутри функции вы используете удобные и понятные имена полей для аргументов `db.add_user()` и `db.complete_user_profile()`. Ваша функция высокого уровня, `create_user()`, больше сосредоточена на `user`. Ее также легче тестировать, потому что вам нужно предоставить только два аргумента для каждого теста.

### Чтение табличных данных из файлов и баз данных

Довольно распространенным случаем использования именованных кортежей является их применение для хранения записей в базе данных. Вы можете определить классы `namedtuple`, используя имена столбцов в качестве имен полей, и извлекать данные из строк базы данных в именованные кортежи. Нечто подобное можно сделать и с [CSV-файлами](https://realpython.com/python-csv/).

Например, допустим, у вас есть CSV-файл с данными о сотрудниках вашей компании, и вы хотите считать эти данные в подходящую структуру данных для дальнейшей обработки. Ваш CSV-файл выглядит следующим образом:
```CSV
name,job,email
"Linda","Technical Lead","linda@example.com"
"Joe","Senior Web Developer","joe@example.com"
"Lara","Project Manager","lara@example.com"
"David","Data Analyst","david@example.com"
"Jane","Senior Python Developer","jane@example.com"
```

Вы подумываете использовать Python [модуль `csv`](https://docs.python.org/3/library/csv.html#module-csv) и его [`DictReader`](https://docs.python.org/3/library/csv.html#csv.DictReader) для обработки файла, но у вас есть дополнительное требование - вам нужно хранить данные в неизменяемой и легковесной структуре данных. В этом случае хорошим выбором может стать `именованный кортеж`:
```python
import csv
>>> from collections import namedtuple

>>> with open("employees.csv", "r") as csv_file:
...     reader = csv.reader(csv_file)
...     Employee = namedtuple("Employee", next(reader), rename=True)
...     for row in reader:
...         employee = Employee(*row)
...         print(employee.name, employee.job, employee.email)
...
Linda Technical Lead linda@example.com
Joe Senior Web Developer joe@example.com
Lara Project Manager lara@example.com
David Data Analyst david@example.com
Jane Senior Python Developer jane@example.com
```

В этом примере вы сначала открываете файл `employees.csv` в операторе [`with`](https://realpython.com/python-with-statement/). Затем вы используете [`csv.reader()`](https://docs.python.org/3/library/csv.html?highlight=csv#csv.reader) для получения итератора по строкам в CSV-файле. С помощью `namedtuple()` вы создаете новый класс `Employee`. Вызов [`next()`](https://docs.python.org/3/library/functions.html#next) получает первую строку данных из `reader`, которая содержит заголовок файла CSV. Этот заголовок содержит имена полей для вашего `namedtuple`.

>**Примечание:** Когда вы создаете `namedtuple` на основе имен полей, которые вы не можете контролировать, вы должны установить `.rename` в `True`. Таким образом, вы предотвратите проблемы с недопустимыми именами полей, что может быть распространенной ситуацией при работе с таблицами и запросами баз данных, CSV-файлами или любыми другими типами табличных данных.

Наконец, цикл [`for`](https://realpython.com/python-for-loop/) создает экземпляр `Employee` из каждой `строки` в CSV-файле и [выводит](https://realpython.com/python-print/) список сотрудников на экран.

## Использование `namedtuple` vs другие структуры данных

Итак, вы узнали, как создавать именованные кортежи, чтобы сделать ваш код более читабельным, явным и питонским. Вы также написали несколько примеров, которые помогут вам найти возможности для использования именованных кортежей в вашем коде.

В этом разделе вы рассмотрите сходства и различия между классами `namedtuple` и другими структурами данных Python, такими как словари, дата классы и типизированные именованные кортежи. Вы сравните именованные кортежи с другими структурами данных по следующим характеристикам:

- Читаемость
- Изменяемость
- Потребление памяти
- Производительность

Таким образом, вы будете лучше подготовлены к выбору правильной структуры данных для конкретного случая использования.


### `namedtuple` vs Словарь

[Словарь](https://realpython.com/python-dicts/) - это фундаментальная структура данных в Python. Сам язык построен на словарях, поэтому они повсюду. Поскольку они настолько распространены и полезны, вы, вероятно, часто используете их в своем коде. Но насколько словари отличаются от именованных кортежей?

С точки зрения читаемости, вероятно, можно сказать, что словари так же удобочитаемы, как и именованные кортежи. Несмотря на то, что они не предоставляют возможности доступа к атрибутам через точечную нотацию, поиск ключей в словарях достаточно читабелен и прост:
```python
from collections import namedtuple

>>> jane = {"name": "Jane", "age": 25, "height": 1.75}
>>> jane["age"]
25

>>> # Эквивалентный именованный кортеж
>>> Person = namedtuple("Person", "name age height")
>>> jane = Person("Jane", 25, 1.75)
>>> jane.age
25
```

В обоих примерах у вас есть полное понимание кода и его замысла. Однако определение именованного кортежа требует двух дополнительных строк кода: одна строка для [импорта](https://realpython.com/python-import/) фабричной функции `namedtuple()` и другая для определения класса `namedtuple`, `Person`.

Большое различие между обеими структурами данных заключается в том, что словари являются [изменяемыми](https://docs.python.org/3/glossary.html#term-mutable), а именованные кортежи - неизменяемыми. Это означает, что вы _можете_ изменять словари на месте, но вы _не можете_ изменять именованные кортежи:
```python
from collections import namedtuple

>>> jane = {"name": "Jane", "age": 25, "height": 1.75}
>>> jane["age"] = 26
>>> jane["age"]
26
>>> jane["weight"] = 67
>>> jane
{'name': 'Jane', 'age': 26, 'height': 1.75, 'weight': 67}

>>> # Эквивалентный именованный кортеж
>>> Person = namedtuple("Person", "name age height")
>>> jane = Person("Jane", 25, 1.75)

>>> jane.age = 26
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: can't set attribute

>>> jane.weight = 67
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Person' object has no attribute 'weight'
```

Вы можете обновить значение существующего ключа в словаре, но не можете сделать то же самое в именованном кортеже. Вы можете добавлять новые пары ключ-значение в существующие словари, но вы не можете добавлять пары поле-значение в существующие именованные кортежи.

>**Примечание:** В именованных кортежах вы можете использовать `._replace()` для обновления значения данного поля, но этот метод создает и возвращает новый экземпляр именованного кортежа вместо того, чтобы обновлять исходный экземпляр на месте.

В общем, если вам нужна неизменяемая структура данных для правильного решения конкретной задачи, то рассмотрите возможность использования именованного кортежа вместо словаря, чтобы удовлетворить ваши требования.

Что касается использования памяти, то именованные кортежи являются довольно легковесной структурой данных. Запустите свой [редактор кода или IDE](https://realpython.com/python-ides-code-editors-guide/) и создайте следующий скрипт:
```python
# namedtuple_dict_memory.py

from collections import namedtuple
from pympler import asizeof

Point = namedtuple("Point", "x y z")
point = Point(1, 2, 3)

namedtuple_size = asizeof.asizeof(point)
dict_size = asizeof.asizeof(point._asdict())
gain = 100 - namedtuple_size / dict_size * 100

print(f"namedtuple: {namedtuple_size} bytes ({gain:.2f}% smaller)")
print(f"dict:       {dict_size} bytes")
```

Этот небольшой скрипт использует `asizeof.asizeof()` из [Pympler](https://pympler.readthedocs.io/en/latest/) для получения объема памяти именованного кортежа и эквивалентного ему словаря.

>**Примечание:** Pympler - это инструмент для мониторинга и анализа поведения памяти объектов Python.
>
Вы можете установить его из [PyPI](https://realpython.com/pypi-publish-python-package/), используя [`pip`](https://realpython.com/what-is-pip/), как обычно:
>```shell
$ pip install pympler
>```
>После выполнения этой команды Pympler будет доступен в вашей [окружении Python](https://realpython.com/effective-python-environment/), и вы сможете запустить вышеуказанный сценарий.

Если вы [запустите сценарий](https://realpython.com/run-python-scripts/) из командной строки, то получите следующий результат:
```shell
$ python namedtuple_dict_memory.py
namedtuple: 160 bytes (67.74% smaller)
dict:       496 bytes
```

Этот отчет подтверждает, что именованные кортежи потребляют меньше памяти, чем эквивалентные словари. Поэтому если потребление памяти является для вас ограничением, то вам следует рассмотреть возможность использования именованных кортежей вместо словарей.

>**Примечание:** Когда вы сравниваете именованные кортежи и словари, окончательная разница в потреблении памяти будет зависеть от количества значений и их типов. При разных значениях вы получите разные результаты.

Наконец, вам нужно иметь представление о том, насколько именованные кортежи и словари отличаются по производительности операций. Для этого вы протестируете операции [принадлежности](https://realpython.com/python-boolean/#the-in-operator) и доступа к атрибутам. Вернитесь к своему редактору кода и создайте следующий сценарий:
```python
# namedtuple_dict_time.py

from collections import namedtuple
from time import perf_counter

def average_time(structure, test_func):
    time_measurements = []
    for _ in range(1_000_000):
        start = perf_counter()
        test_func(structure)
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(1e9)

def time_dict(dictionary):
    "x" in dictionary
    "missing_key" in dictionary
    2 in dictionary.values()
    "missing_value" in dictionary.values()
    dictionary["y"]

def time_namedtuple(named_tuple):
    "x" in named_tuple._fields
    "missing_field" in named_tuple._fields
    2 in named_tuple
    "missing_value" in named_tuple
    named_tuple.y

Point = namedtuple("Point", "x y z")
point = Point(x=1, y=2, z=3)

namedtuple_time = average_time(point, time_namedtuple)
dict_time = average_time(point._asdict(), time_dict)
gain = dict_time / namedtuple_time

print(f"namedtuple: {namedtuple_time:.2f} ns ({gain:.2f}x faster)")
print(f"dict:       {dict_time:.2f} ns")
```

Этот сценарий выполняет операции, общие для словарей и именованных кортежей, такие как проверка принадлежности и доступ к атрибутам. Запуск сценария на вашей текущей системе отображает вывод, подобный следующему:
```shell
$ namedtuple_dict_time.py
namedtuple: 527.26 ns (1.36x faster)
dict:       717.71 ns
```

Этот отчет показывает, что операции над именованными кортежами выполняются немного быстрее, чем аналогичные операции над словарями.

### `namedtuple` vs Data Class
[Python 3.7](https://realpython.com/python37-new-features/) принес с собой новую классную фичу: [дата-классы](https://realpython.com/python-data-classes/). Согласно [PEP 557](https://www.python.org/dev/peps/pep-0557/), дата-классы похожи на именованные кортежи, но они изменяемы:

> Дата-классы можно рассматривать как "изменяемые именованные кортежи с параметрами по умолчанию". ([Источник](https://www.python.org/dev/peps/pep-0557/#abstract))

Однако точнее было бы сказать, что дата-классы похожи на изменяемые именованные кортежи с [подсказками типов](https://realpython.com/python-type-checking/). В части "по умолчанию" нет никакой разницы, поскольку именованные кортежи также могут иметь значения по умолчанию для своих полей. Итак, на первый взгляд, основными отличиями являются изменяемость и подсказки типов.

Чтобы создать дата-класс, необходимо импортировать декоратор [`dataclass()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass) из [`dataclasses`](https://docs.python.org/3/library/dataclasses.html#module-dataclasses). Затем вы можете определить свои дата-классы, используя обычный синтаксис определения классов:
```python
from dataclasses import dataclass

>>> @dataclass
... class Person:
...     name: str
...     age: int
...     height: float
...     weight: float
...     country: str = "Canada"
...

>>> jane = Person("Jane", 25, 1.75, 67)
>>> jane
Person(name='Jane', age=25, height=1.75, weight=67, country='Canada')
>>> jane.name
'Jane'
>>> jane.name = "Jane Doe"
>>> jane.name
'Jane Doe'
```

С точки зрения удобочитаемости нет существенных различий между дата-классами и именованными кортежами. Они имеют схожее строковое представление, и вы можете получить доступ к их атрибутам, используя точечную нотацию.

С точки зрения изменяемости, дата-классы являются изменяемыми по определению, поэтому при необходимости вы можете изменить значение их атрибутов. Однако у них есть туз в рукаве. Вы можете установить аргумент `frozen` декоратора `dataclass()` в `True` и сделать их неизменяемыми:
```python
from dataclasses import dataclass

>>> @dataclass(frozen=True)
... class Person:
...     name: str
...     age: int
...     height: float
...     weight: float
...     country: str = "Canada"
...

>>> jane = Person("Jane", 25, 1.75, 67)
>>> jane.name = "Jane Doe"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 4, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'name'
```

Если вы установите `frozen` в `True` в вызове `dataclass()`, то вы сделаете дата-класс неизменяемым. В этом случае при попытке обновить имя Джейн вы получите ошибку [`FrozenInstanceError`](https://docs.python.org/3/library/dataclasses.html#dataclasses.FrozenInstanceError).

Еще одно тонкое различие между именованными кортежами и дата-классами заключается в том, что последние по умолчанию не итерируемы. Продолжим пример с Джейн и попробуем выполнить итерацию ее данных:
```python
for field in jane:
...     print(field)
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'Person' object is not iterable
```

Если вы попытаетесь выполнить итерацию над "голым» дата-классом, то получите `TypeError`. Это типично для обычных классов. К счастью, есть способы ее обойти. Например, вы можете добавить специальный метод [`.__iter__()`](https://docs.python.org/3/library/stdtypes.html#container.__iter__) к `Person` следующим образом:
```python
from dataclasses import astuple, dataclass

>>> @dataclass
... class Person:
...     name: str
...     age: int
...     height: float
...     weight: float
...     country: str = "Canada"
...     def __iter__(self):
...         return iter(astuple(self))
...

>>> for field in Person("Jane", 25, 1.75, 67):
...     print(field)
...
Jane
25
1.75
67
Canada
```

Здесь вы сначала импортируете [`astuple()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple) из `dataclasses`. Эта функция преобразует дата-класс в кортеж. Затем вы передаете полученный кортеж в [`iter()`](https://docs.python.org/3/library/functions.html#iter), чтобы можно было составить и вернуть [итератор](https://docs.python.org/3/library/stdtypes.html#iterator-types) из `.__iter__()`. С помощью этого дополнения вы можете начать итерацию по данным Джейн.

Что касается потребления памяти, именованные кортежи более легковесны, чем дата-классы. Вы можете убедиться в этом, создав и запустив небольшой сценарий, аналогичный тому, который вы видели в предыдущем разделе.

Here’s a script that compares memory usage between a `namedtuple` and its equivalent data class:
```python
# namedtuple_dataclass_memory.py

from collections import namedtuple
from dataclasses import dataclass

from pympler import asizeof

PointNamedTuple = namedtuple("PointNamedTuple", "x y z")

@dataclass
class PointDataClass:
    x: int
    y: int
    z: int

namedtuple_memory = asizeof.asizeof(PointNamedTuple(x=1, y=2, z=3))
dataclass_memory = asizeof.asizeof(PointDataClass(x=1, y=2, z=3))
gain = 100 - namedtuple_memory / dataclass_memory * 100

print(f"namedtuple: {namedtuple_memory} bytes ({gain:.2f}% smaller)")
print(f"data class: {dataclass_memory} bytes")
```

В этом сценарии вы создаете именованный кортеж и дата-класс, содержащий одинаковые данные. Затем вы сравните объемы занимаемой ими памяти.

Вот результаты выполнения вашего сценария:
```shell
$ python namedtuple_dataclass_memory.py
namedtuple: 160 bytes (61.54% smaller)
data class: 416 bytes
```

В отличие от классов `namedtuple`, дата-классы хранят [`.__dict__`](https://docs.python.org/3/library/stdtypes.html#object.__dict__) для хранения [записываемых атрибутов экземпляра](https://realpython.com/python3-object-oriented-programming/#class-and-instance-attributes). Это приводит к увеличению объема памяти.

Далее, вы можете увидеть пример кода, который сравнивает классы `namedtuple` и дата-класс с точки зрения их производительности при доступе к атрибутам.

Приведенный ниже скрипт сравнивает производительность доступа к атрибутам для именованного кортежа и эквивалентного дата-класса:
```python
# namedtuple_dataclass_time.py

from collections import namedtuple
from dataclasses import dataclass
from time import perf_counter

def average_time(structure, test_func):
    time_measurements = []
    for _ in range(1_000_000):
        start = perf_counter()
        test_func(structure)
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(1e9)

def time_structure(structure):
    structure.x
    structure.y
    structure.z

PointNamedTuple = namedtuple("PointNamedTuple", "x y z", defaults=[3])

@dataclass
class PointDataClass:
    x: int
    y: int
    z: int

namedtuple_time = average_time(PointNamedTuple(x=1, y=2, z=3), time_structure)
dataclass_time = average_time(PointDataClass(x=1, y=2, z=3), time_structure)
gain = dataclass_time / namedtuple_time

print(f"namedtuple: {namedtuple_time:.2f} ns ({gain:.2f}x faster)")
print(f"data class: {dataclass_time:.2f} ns")
```

Здесь вы засекаете время операции доступа к атрибуту, потому что это почти единственная общая операция между именованным кортежем и дата-классом. Вы также можете засечь время операций принадлежности, но для этого вам придется получить доступ к атрибуту класса данных `.__dict__`.

С точки зрения производительности, вот результаты:
```shell
$ python namedtuple_dataclass_time.py
namedtuple: 274.32 ns (1.08x faster)
data class: 295.37 ns
```

Разница в производительности минимальна, поэтому можно сказать, что обе структуры данных имеют равнозначную производительность, когда речь идет об операциях доступа к атрибутам.

### `namedtuple` vs `typing.NamedTuple

В Python 3.5 появился [предварительный](https://docs.python.org/3/glossary.html#term-provisional-api) модуль под названием [`typing`](https://docs.python.org/3/library/typing.html#module-typing) для поддержки аннотаций типов функций или [подсказок типов](https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-484). Этот модуль предоставляет [`NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple), который является типизированной версией `namedtuple`. С помощью `NamedTuple` вы можете создавать классы `namedtuple` с подсказками типов. Следуя примеру `Person`, вы можете создать эквивалентный типизированный именованный кортеж следующим образом:
```python
from typing import NamedTuple

>>> class Person(NamedTuple):
...     name: str
...     age: int
...     height: float
...     weight: float
...     country: str = "Canada"
...

>>> issubclass(Person, tuple)
True
>>> jane = Person("Jane", 25, 1.75, 67)
>>> jane.name
'Jane'
>>> jane.name = "Jane Doe"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
```

С помощью `NamedTuple` вы можете создавать подклассы кортежей, которые поддерживают подсказки типов и доступ к атрибутам через точечную нотацию. Поскольку полученный класс является подклассом кортежа, он также неизменяем.

Нюанс, который можно заметить в приведенном выше примере, заключается в том, что подклассы `NamedTuple` выглядят даже более похожими на дата-классы, чем именованные кортежи.

Что касается потребления памяти, то экземпляры `namedtuple` и `NamedTuple` используют одинаковое количество памяти. Вы можете просмотреть сценарий, который сравнивает использование памяти этими двумя типами.

Вот сценарий, который сравнивает использование памяти `namedtuple` и его эквивалента `typing.NamedTuple`:
```python
# typed_namedtuple_memory.py

from collections import namedtuple
from typing import NamedTuple

from pympler import asizeof

PointNamedTuple = namedtuple("PointNamedTuple", "x y z")

class PointTypedNamedTuple(NamedTuple):
    x: int
    y: int
    z: int

namedtuple_memory = asizeof.asizeof(PointNamedTuple(x=1, y=2, z=3))
typed_namedtuple_memory = asizeof.asizeof(
    PointTypedNamedTuple(x=1, y=2, z=3)
)

print(f"namedtuple:        {namedtuple_memory} bytes")
print(f"typing.NamedTuple: {typed_namedtuple_memory} bytes")
```

В этом сценарии вы создаете именованный кортеж и эквивалентный ему типизированный экземпляр `NamedTuple`. Затем вы сравниваете потребление памяти обоими экземплярами.

На этот раз сценарий, сравнивающий потребление памяти, выдает следующий результат:
```shell
$ python typed_namedtuple_memory.py
namedtuple:        160 bytes
typing.NamedTuple: 160 bytes
```

В данном случае оба экземпляра потребляют одинаковое количество памяти, так что на этот раз победителя нет.

Поскольку классы `namedtuple` и подклассы `NamedTuple` являются подклассами `tuple`, у них много общего. В этом случае вы можете засечь время на тесты принадлежности для полей и значений. Вы также можете засечь время доступа к атрибутам с помощью точечной нотации. 

Следующий сценарий сравнивает производительность `namedtuple` и `typing.NamedTuple`:
```python
# typed_namedtuple_time.py

from collections import namedtuple
from time import perf_counter
from typing import NamedTuple

def average_time(structure, test_func):
    time_measurements = []
    for _ in range(1_000_000):
        start = perf_counter()
        test_func(structure)
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(1e9)

def time_structure(structure):
    "x" in structure._fields
    "missing_field" in structure._fields
    2 in structure
    "missing_value" in structure
    structure.y

PointNamedTuple = namedtuple("PointNamedTuple", "x y z")

class PointTypedNamedTuple(NamedTuple):
    x: int
    y: int
    z: int

namedtuple_time = average_time(PointNamedTuple(x=1, y=2, z=3), time_structure)
typed_namedtuple_time = average_time(
    PointTypedNamedTuple(x=1, y=2, z=3), time_structure
)

print(f"namedtuple:        {namedtuple_time:.2f} ns")
print(f"typing.NamedTuple: {typed_namedtuple_time:.2f} ns")
```

В этом сценарии сначала создается именованный кортеж, а затем типизированный именованный кортеж с аналогичным содержимым. Затем вы сравниваете производительность общих операций над обеими структурами данных.

Вот результаты:
```shell
$ python typed_namedtuple_time.py
namedtuple:        503.34 ns
typing.NamedTuple: 509.91 ns
```

В этом случае можно сказать, что обе структуры данных ведут себя практически одинаково с точки зрения производительности. Кроме того, использование `NamedTuple` для создания именованных кортежей может сделать ваш код еще более явным, поскольку вы можете добавить информацию о типе к полям. Вы также можете предоставлять значения по умолчанию, добавлять новые функциональные возможности и писать [docstrings](https://realpython.com/documenting-python-code/#documenting-your-python-code-base-using-docstrings) для ваших типизированных именованных кортежей.

В этом разделе вы узнали много нового о `namedtuple` и других подобных структурах данных и классах. Вот таблица, в которой кратко описано сравнение `namedtuple` со структурами данных, рассмотренными в этом разделе:

|                  | `   dict` | Data Class                                            | `NamedTuple` |
| ---------------- | --------- | ----------------------------------------------------- | ------------ |
| **Читабельность**  | Similar   | Равная                                                 | Равная        |
| **Неизменность** | Нет        | По умаолчанию нет. Да, если использовать `@dataclass(frozen=True)` | Да          |
| **Потребление памяти** | Выше    | Выше                                                | Равная        |
| **Производительность**  | Медленнее    | Схожая                                               | Схожая      |
| **Итерируемость**  | Да       | Нет - по умолчанию. Да, при условии реализации `.__iter__()`.         | Да          |

С помощью этого краткого обзора вы сможете выбрать структуру данных, которая лучше всего соответствует вашим текущим потребностям. Кроме того, следует учесть, что дата-классы и `NamedTuple` позволяют добавлять подсказки типов, что в настоящее время является весьма желательной фичей в коде Python.

## Подклассификация классов `namedtuple`.

Поскольку классы `namedtuple` являются обычными классами Python, вы можете создавать их подклассы, если вам нужно обеспечить дополнительные функциональные возможности, docstring, удобное для пользователя строковое представление и так далее.

Например, хранение возраста человека в объекте не считается лучшей практикой. Поэтому вы, вероятно, захотите хранить дату рождения и вычислять возраст по мере необходимости:
```python
from collections import namedtuple
>>> from datetime import date

>>> BasePerson = namedtuple(
...     "BasePerson",
...     "name birthdate country",
...     defaults=["Canada"]
... )

>>> class Person(BasePerson):
...     """A namedtuple subclass to hold a person's data."""
...     __slots__ = ()
...     def __repr__(self):
...         return f"Name: {self.name}, age: {self.age} years old."
...     @property
...     def age(self):
...         return (date.today() - self.birthdate).days // 365
...

>>> Person.__doc__
"A namedtuple subclass to hold a person's data."

>>> jane = Person("Jane", date(1996, 3, 5))
>>> jane.age
25
>>> jane
Name: Jane, age: 25 years old.
```

`Person` наследуется от `BasePerson`, который является классом `namedtuple`. В определении подкласса сначала добавляется строка docstring для описания того, что делает класс. Затем вы устанавливаете [`__slots__`](https://docs.python.org/3/reference/datamodel.html#object.__slots__) в пустой кортеж, что предотвращает автоматическое создание `.__dict__` для каждого экземпляра. Это позволяет вашему подклассу `BasePerson` экономить память.

Вы также добавляете пользовательский [`.__repr__()`](https://docs.python.org/3/reference/datamodel.html#object.__repr__), чтобы обеспечить удобное строковое представление класса. Наконец, вы добавляете [property](https://realpython.com/python-descriptors/#python-descriptors-in-properties) для вычисления возраста человека, используя [`datetime`](https://realpython.com/python-datetime/).


## Измерение времени создания: `tuple` против `namedtuple`

До сих пор вы сравнивали классы `namedtuple` с другими структурами данных по нескольким характеристикам. В этом разделе вы рассмотрите, как обычные кортежи и именованные кортежи сравниваются по времени **создания**.

Допустим, у вас есть приложение, которое динамически создает тонну кортежей. Вы решили сделать свой код более питоновским и удобным для поддержки, используя именованные кортежи. После того, как вы обновили всю свою [кодовую базу](https://en.wikipedia.org/wiki/Codebase) для использования именованных кортежей, вы запускаете приложение и замечаете некоторые проблемы с производительностью. После некоторых тестов вы пришли к выводу, что проблемы могут быть связаны с динамическим созданием именованных кортежей.

Вот сценарий, который измеряет среднее время, необходимое для динамического создания нескольких кортежей и именованных кортежей:
```python
# tuple_namedtuple_time.py

from collections import namedtuple
from time import perf_counter

def average_time(test_func):
    time_measurements = []
    for _ in range(1_000):
        start = perf_counter()
        test_func()
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(1e9)

def time_tuple():
    tuple([1] * 1000)

fields = [f"a{n}" for n in range(1000)]
TestNamedTuple = namedtuple("TestNamedTuple", fields)

def time_namedtuple():
    TestNamedTuple(*([1] * 1000))

namedtuple_time = average_time(time_namedtuple)
tuple_time = average_time(time_tuple)
gain = namedtuple_time / tuple_time

print(f"tuple:      {tuple_time:.2f} ns ({gain:.2f}x faster)")
print(f"namedtuple: {namedtuple_time:.2f} ns")
```

В этом сценарии вы рассчитываете среднее время, необходимое для создания нескольких кортежей и эквивалентных им именованных кортежей. Если вы запустите сценарий из командной строки, то получите результат, похожий на следующий:
```shell
$ python tuple_namedtuple_time.py
tuple:      7075.82 ns (3.36x faster)
namedtuple: 23773.67 ns
```

Если посмотреть на этот результат, можно увидеть, что динамическое создание объектов `tuple` намного быстрее, чем создание аналогичных именованных кортежей. В некоторых ситуациях, например, при работе с большими базами данных, дополнительное время, необходимое для создания именованного кортежа, может серьезно повлиять на производительность вашего приложения, поэтому следите за этим, если ваш код создает много кортежей динамически.

## Заключение

Написание [питонского](https://realpython.com/learning-paths/writing-pythonic-code/) кода является востребованным навыком в сфере разработки на Python. Питонский код является читабельным, явным, чистым, удобным для поддержки и использует преимущества идиом и лучших практик Python. В этом уроке вы узнали о создании классов и экземпляров `namedtuple` и о том, как они могут помочь вам улучшить качество вашего кода Python.

**В этом руководстве вы узнали:**.

- Как создавать и использовать классы и экземпляры **`namedtuple`**
- Как использовать преимущества крутых возможностей **`namedtuple`**.
- Когда использовать экземпляры ``namedtuple`` для написания **питонского кода**
- Когда использовать ``именованный кортеж`` вместо аналогичной **структуры данных**
- Как **создавать подклассы `именованных кортежей`** для добавления новых возможностей

Обладая этими знаниями, вы сможете значительно улучшить качество вашего существующего и будущего кода. Если вы часто используете кортежи, то подумайте о том, чтобы превратить их в именованные кортежи, когда это имеет смысл. Это сделает ваш код намного более читабельным и питонским.